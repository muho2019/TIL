# 인터페이스와 구현 클래스: 언제 어떻게 사용할까?

예전에는 서비스 계층에 인터페이스를 만드는 것이 거의 표준처럼 여겨졌지만, 최근의 스프링 개발 트렌드에서는 꼭 필요한 상황이 아니라면 인터페이스 없이 구체 클래스를 바로 사용하는 것을 더 선호하는 추세입니다.

그 이유를 과거와 현재의 변화를 통해 설명해 드리겠습니다.

## 과거: 인터페이스가 표준이었던 이유

과거에 `SomeService` 인터페이스와 `SomeServiceImpl` 구현 클래스를 만드는 것이 일반적이었던 이유는 크게 두 가지입니다.

- AOP를 위한 JDK Dynamic Proxy: 과거 스프링은 트랜잭션(`@Transactional`)과 같은 AOP(관점 지향 프로그래밍) 기능을 적용할 때 JDK Dynamic Proxy를 기본으로 사용했습니다. 이 방식은 반드시 인터페이스가 있어야만 프록시 객체를 만들 수 있다는 기술적인 제약이 있었습니다. 따라서 `@Transactional`을 쓰기 위해서라도 인터페이스는 필수적이었습니다.
- 구현체 교체의 유연성 (DI의 핵심 철학): "언제든지 구현 클래스를 쉽게 바꿀 수 있어야 한다"는 객체 지향의 원칙 때문입니다. 예를 들어, 지금은 JPA를 쓰지만 나중에는 MyBatis나 다른 기술로 바꿀 수 있으니, `AvailabilityService`라는 인터페이스에 의존하고 실제 구현체는 `JpaAvailabilityService`로 만들자는 생각이었습니다.

## 현재: 인터페이스 없이도 괜찮은 이유 (그리고 더 나은 이유)

하지만 스프링 부트가 대중화된 지금은 상황이 많이 바뀌었습니다.

- CGLIB의 기본 사용: 최신 스프링 부트는 AOP를 적용할 때 CGLIB라는 기술을 기본으로 사용합니다. CGLIB는 인터페이스가 없어도 구체 클래스를 상속받아 프록시를 만드는 방식이라 기술적인 제약이 사라졌습니다. 즉, 인터페이스가 없어도 `@Transactional` 같은 기능이 아주 잘 동작합니다.
- 불필요한 추상화 (YAGNI 원칙): "You Ain't Gonna Need It (그거 필요 없을걸)"이라는 원칙입니다. 실제로 프로젝트를 진행하면서 서비스의 구현 기술 전체를 바꾸는 경우는 거의 없습니다. 단 하나의 구현체만 존재할 것이 거의 확실한 상황에서 미리 인터페이스를 만드는 것은 불필요한 추상화이며, 코드의 복잡성만 높입니다.
  - 클래스 파일이 2배로 늘어납니다 (`AvailabilityService.java`, `AvailabilityServiceImpl.java`).
  - 코드를 탐색할 때 인터페이스와 구현체를 번갈아 봐야 해서 번거롭습니다.
- 테스트의 편리성: 과거에는 Mock 객체를 만들기 위해 인터페이스가 편리했지만, Mockito와 같은 최신 테스트 프레임워크는 구체 클래스도 아주 쉽게 Mocking할 수 있도록 지원합니다. 따라서 테스트를 위해 인터페이스를 만들 필요도 없어졌습니다.

## 그럼에도 인터페이스가 꼭 필요한 경우

물론 인터페이스가 더 이상 필요 없다는 뜻은 절대 아닙니다. 다음과 같은 명확한 상황에서는 인터페이스를 사용하는 것이 올바른 설계입니다.

- 다형성이 실제로 필요한 경우: 하나의 인터페이스에 대해 여러 구현체가 존재하고, 상황에 따라 구현체를 바꿔서 사용해야 할 때입니다.
  - 예시: `NotificationService`라는 인터페이스를 두고, `SmsNotificationService`, `EmailNotificationService`, `KakaoNotificationService`를 구현하여 필요에 따라 골라 쓰는 경우.
- 외부에 제공되는 API 모듈일 경우: 우리가 만든 서비스를 다른 팀이나 외부에 라이브러리 형태로 제공해야 한다면, 인터페이스를 통해 공개할 기능(Public API)을 명확히 정의하고 내부 구현을 숨기는 것이 좋습니다.

결론적으로, 내부적으로 사용되고 구현체가 하나만 있을 것이 명확한 서비스는 인터페이스 없이 구체 클래스로 시작하는 것이 더 단순하고 실용적인 선택입니다. 나중에 정말로 다른 구현체가 필요해지는 시점에 인터페이스를 추출(Extract Interface)해도 늦지 않습니다.
