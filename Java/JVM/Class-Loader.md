# 클래스 로더

클래스 로더는 클래스 로딩 단계에서 '완전한 이름을 바탕으로 해당 클래스를 정의하는 바이너리 바이트 스트림을 가져오는' 작업을 수행하는 코드입니다.

## 독립적인 이름 공간

- 클래스 로더는 유일하지 않으며 각자 **독립적인 클래스 이름 공간**을 가집니다.
- 두 클래스의 동치성 판단은 **같은 클래스 로더로 로드했을 때만** 의미가 있습니다.
- 동일한 클래스라도 **서로 다른 클래스 로더**에서 로드하면 **다른 클래스**로 인식됩니다.

## 동치성 판단

- `equals()` 메서드
- `isAssignableFrom()` 메서드
- `isInstance()` 메서드
- `instanceof` 키워드

## 부모 위임 모델 (Parents Delegation Model)

### 클래스 로더의 분류

JVM 관점에서 클래스 로더는 두 종류로 나뉩니다.

1. **부트스트랩 클래스 로더**: JVM 자체의 일부
2. **기타 모든 클래스 로더**: `java.lang.ClassLoader`를 상속하여 자바로 구현되며, JVM 외부에 독립적으로 존재

### JDK 9 이전의 3계층 클래스 로더

1. 부트스트랩 클래스 로더

- **역할**: `JAVA_HOME/lib` 디렉터리나 `-Xbootclasspath` 매개변수로 지정한 경로의 파일들과 JVM이 인식하는 클래스 라이브러리 로드
- **특징**: 자바 프로그램에서 직접 참조 불가

2. 확장 클래스 로더 (`sun.misc.Launcher$ExtClassLoader`)

- **구현**: 자바로 구현
- **역할**: `JAVA_HOME/lib/ext` 디렉터리 또는 `java.ext.dirs` 시스템 변수로 지정한 경로의 클래스 라이브러리 로드
- **목적**: 자바 시스템의 클래스 라이브러리 확장 메커니즘
- **특징**: 개발자가 프로그램에서 직접 사용 가능

3. 애플리케이션 클래스 로더 (`sun.misc.Launcher$AppClassLoader`)

- **별칭**: 시스템 클래스 로더 (`getSystemClassLoader` 메서드가 반환하는 클래스 로더)
- **역할**: 클래스패스상의 클래스 라이브러리 로드
- **특징**: 개발자가 자바 코드에서 직접 사용 가능. 별도의 클래스 로더를 만들지 않은 경우 **기본 클래스 로더**가 됨

### 계층 구조와 동작 원리

```
부트스트랩 클래스 로더
|
확장 클래스 로더
|
애플리케이션 클래스 로더
|                       |
사용자 정의 클래스 로더    사용자 정의 클래스 로더
```

**위임 과정**

1. 클래스 로딩 요청을 받은 클래스 로더는 **직접 로드하지 않고** 상위 클래스 로더로 위임합니다.
2. 모든 요청으 최상위인 **부트스트랩 클래스 로더**까지 전달됩니다.
3. 상위 로더가 해당 클래스를 찾을 수 없으면, 비로소 하위 로더가 로드를 시도합니다.

**부모-자식 관계**

- **상속보다는 컴포지션** 관계로 구현하여 부모 로더의 코드를 재사용합니다.

**장점**

- 자바 클래스들이 자연스럽게 클래스 로더의 계층 구조를 따르게 됩니다.
- `java.lang.Object` 같은 핵심 클래스는 어떤 클래스 로더에 요청해도 부트스트랩 클래스 로더가 처리하여 동일성이 보장됩니다.

## 자바 모듈 시스템 (JDK 9+)

JDK 9에서 도입된 직소 프로젝트(JPMS)는 자바 기술의 중요한 개선사항입니다.

### 모듈 정의 요소

- requires: 다른 모듈에 대한 의존성 목록
- exports: 다른 모듈에서 사용할 수 있는 패키지 목록
- open: 다른 모듈에서 리플렉션 API로 접근할 수 있는 패키지
- uses: 현재 모듈이 사용할 서비스 목록
- provides: 다른 모듈에 제공하는 서비스 목록

### 기존 방식과의 차이점

**JDK 8 이전 (클래스패스 기반)**

- 필요한 타입이 없어도 런타임에서야 예외 발생
- 의존성 관리의 안정성 문제

**JDK 9 이후 (모듈 기반)**

- 의존성을 명시적으로 선언하여 **개발 단계에서 확인** 가능
- 의존성 누락 시 **애플리케이션 시작 자체가 불가능**하여 런타임 예외 방지

### 모듈 호환성

자바 모듈 시스템이 기존 클래스패스 방식과 호환되도록 하기 위해 JDK 9에서는 클래스패스에 해당하는 모듈패스 개념을 도입했습니다.

- 클래스패스: 전통적인 JAR 패키지로 취급 (`module-info.class` 포함 여부 무관)
- 모듈패스: 모듈로 취급 (`module-info.class` 미포함이어도 모듈로 처리)

**접근 규칙**

기존 자바 애플리케이션의 호환성을 위해 세 가지 접근 규칙을 적용합니다.

- 클래스패스상의 JAR 파일용 접근 규칙
- 모듈패스상의 모듈용 접근 규칙
- 모듈패스상의 JAR 파일용 접근 규칙

### 모듈화 시대의 클래스 로더

**주요 변경점**

1. **확장 클래스 로더 -> 플랫폼 클래스 로더**로 대체
   - JDK 전체 모듈화로 확장성 요구사항이 자연스럽게 충족
   - `JAVA_HOME/lib/ext` 디렉터리와 `java.ext.dirs` 시스템 변수 사용 불필요
2. 상속 구조 변경
   - 기존: `java.net.URLClassLoader`에서 파생
   - 현재: `jdk.internal.loader.BuiltinClassLoader`에서 파생

**위임 관계의 변화**

JDK 9는 **3계층 구조와 부모 위임 모델을 유지**하지만, 위임 방식이 개선되었습니다.

1. 플랫폼 및 애플리케이션 클래스 로더가 요청을 받으면
2. **부모 로더 위임 전**에 해당 클래스가 **특정 시스템 모듈**에 속하는지 확인
3. 특정 시스템 모듈에 속한다면 **해당 모듈 담당 로더**에 직접 위임
