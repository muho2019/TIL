# JVM 런타임 데이터 영역 (Runtime Data Area)

**모든 스레드가 공유하는 데이터 영역**

- 메서드 영역 (Method Area)
- 힙 (Heap)

**스레드별 개별 영역 (Thread-Private)**

- PC 레지스터 (Program Counter Register)
- JVM 스택 (Java Virtual Machine Stack)
- 네이티브 메서드 스택 (Native Method Stack)

## 1. PC 레지스터 (Program Counter Register)

PC 레지스터는 현재 스레드가 실행하고 있는 JVM 명령어의 주소를 저장하는 공간입니다.

멀티스레드 환경에서는 CPU가 여러 스레드를 번갈아 가며 실행하기 때문에, 스레드가 다시 자기 차례로 돌아왔을 때 이전에 멈췄던 부분부터 정확히 실행을 이어가야 합니다. PC 레지스터가 바로 이 '멈췄던 지점'을 기억하는 역할을 합니다.

- 스레드별 독립성: 각 스레드는 자신만의 PC 레지스터를 가지며, 다른 스레드에 영향을 주지 않습니다.
- 상태 기록:
  - Java 메서드 실행 시: 현재 실행 중인 바이트코드 명령어의 주소를 가리킵니다.
  - Native 메서드 실행 시: 값이 정의되지 않습니다 (Undefined).
- 메모리 예외: JVM 런타임 데이터 영역 중 유일하게 `OutOfMemoryError`가 발생하지 않는 영역입니다.

## 2. JVM 스택 (Java Virtual Machine Stack)

JVM 스택은 Java 메서드 호출과 관련된 정보를 저장하는 스레드별 메모리 영역입니다. 메서드가 호출될 때마다 하나의 스택 프레임(Stack Frame)이 이 스택에 쌓이고(push), 메서드가 종료되면 해당 프레임이 제거(pop)됩니다.

- 스택 프레임의 구성 요소:
  - 지역 변수 테이블 (Local Variable Table): 메서드 내에서 사용하는 지역 변수, 매개변수 등이 저장됩니다. 컴파일 시점에 크기가 결정됩니다.
  - 피연산자 스택 (Operand Stack): 메서드의 실제 계산 작업을 위한 공간입니다. 바이트코드 명령어는 이곳의 데이터를 피연산자로 사용하고 그 결과를 다시 푸시합니다.
  - 동적 링크 (Dynamic Linking): 런타임에 상수 풀(Constant Pool)을 통해 특정 메서드를 찾아 연결하는 역할을 합니다.
  - 메서드 반환 정보: 메서드가 정상적으로 또는 예외를 통해 종료될 때, 호출한 메서드로 돌아갈 위치와 결과 값을 담습니다.

일반적으로 개발자들이 '스택 메모리'라고 부르는 것은 바로 이 JVM 스택을 가리킬 때가 많습니다. 스택의 크기가 제한되어 있어 너무 깊게 메서드를 호출하면 `StackOverflowError`가 발생할 수 있습니다.

## 3. 네이티브 메서드 스택 (Native Method Stack)

JVM 스택이 Java 메서드를 위한 공간이라면, 네이티브 메서드 스택은 C, C++ 등 Native 코드로 작성된 메서드를 위한 공간입니다. 그 외의 원리는 JVM 스택과 거의 동일합니다.

JVM 명세에는 네이티브 메서드 스택에 대한 구체적인 구현 방식이 정의되어 있지 않아, JVM 구현체에 따라 JVM 스택과 네이티브 메서드 스택을 하나로 통합하여 구현하기도 합니다. (예: HotSpot VM)

## 4. 힙 (Heap)

힙은 객체 인스턴스와 배열이 생성되는 공간으로, JVM 런타임 데이터 영역 중 가장 큰 메모리 영역을 차지합니다.

- 전역 공유: 모든 스레드가 공유하며, 여기에 생성된 객체는 모든 스레드에서 접근 가능합니다.
- GC의 주 관리 대상: 가비지 컬렉터(Garbage Collector)가 더 이상 참조되지 않는 객체들을 찾아내 메모리를 회수하는 주된 영역입니다. 이 때문에 'GC Heap'이라고도 불립니다.
- 세대별 GC (Generational GC): 대부분의 GC는 '젊은 객체는 금방 죽는다'는 가설 아래 힙을 Young Generation(Eden, Survivor 0/1)과 Old Generation 영역으로 나누어 관리합니다. (이는 보편적인 구현 방식일 뿐, JVM 명세에 강제된 사항은 아닙니다.)
- TLAB (Thread-Local Allocation Buffer): 스레드 간의 경합을 줄여 객체 할당 속도를 높이기 위해 각 스레드별로 힙 내에 작은 할당 버퍼를 두는 최적화 기법입니다.

힙 공간이 부족하면 `OutOfMemoryError`가 발생합니다.

## 5. 메서드 영역 (Method Area)

메서드 영역은 힙과 마찬가지로 모든 스레드가 공유하는 메모리 영역입니다. JVM이 시작될 때 생성되며 힙 영역의 논리적인 일부이지만 구현에 따라 힙과 분리하여 '논힙(Non-Heap)'으로 부르기도 합니다.

이 영역에는 다음과 같이 클래스와 관련된 고정된(fixed) 데이터가 주로 저장됩니다.

- 타입 정보 (Type Information): 클래스와 인터페이스의 이름, 구조, 상속 관계 등
- 필드 및 메서드 정보: 클래스의 멤버 변수와 메서드에 대한 정보
- 정적 변수 (Static Variables)
- 런타임 상수 풀 (Runtime Constant Pool)
- JIT 컴파일러가 컴파일한 코드 캐시

메서드 영역의 공간이 부족해지면 힙과 마찬가지로 `OutOfMemoryError`가 발생합니다.

### PermGen에서 Metaspace로의 변화 (JDK 8+)

과거 Java 7 이전 버전에서는 메서드 영역을 **영구 세대**(Permanent Generation, PermGen)라는 힙의 일부 영역에 구현했습니다.

- **문제점**: PermGen은 힙 크기(-Xmx)에 의해 최대 크기가 제한되었습니다. 이 때문에 동적으로 클래스를 많이 로딩하는(e.g., JSP, OSGi) 애플리케이션에서 `OutOfMemoryError: PermGen space` 오류가 빈번하게 발생했습니다.
- **개선 (Metaspace)**: JDK 8부터는 PermGen을 완전히 삭제하고, **메타스페이스**(Metaspace)라는 **네이티브 메모리 영역**에 메서드 영역을 구현했습니다.
  - 장점: Metaspace는 OS가 가용하는 네이티브 메모리를 사용하므로, PermGen 시절의 고정된 크기 제한에서 훨씬 자유로워졌습니다. 이로 인해 관련 메모리 오류 발생 가능성이 크게 줄었습니다.

### 5-1. 런타임 상수 풀

런타임 상수 풀은 **메서드 영역에 포함되는 핵심적인 데이터 구조**입니다. 클래스 파일이 로드될 때, 해당 파일 내의 `constant_pool` 테이블 정보가 이곳에 저장됩니다.

- 저장 내용: 컴파일 시점에 결정된 각종 리터럴(e.g., 숫자, 문자열)과 **심볼릭 레퍼런스**(Symbolic Reference)가 저장됩니다.
  - 심볼릭 레퍼런스: 특정 필드나 메서드를 가리키는 이름 기반의 참조입니다. (e.g., `com.my.MyClass.myMethod`)
- 중요한 특징: 동적(Dynamic) 특성
  - 클래스 파일의 상수 풀은 컴파일 시점에 고정되지만, **런타임 상수 풀의 내용은 동적으로 변경될 수 있습니다.**
  - 예시: `String.intern()` 메서드는 런타임에 호출될 수 있습니다. 이 메서드는 주어진 문자열이 런타임 상수 풀(정확히는 String Table)에 없으면 새로 추가하고 그 참조를 반환합니다. 이처럼 프로그램 실행 중에 새로운 상수가 추가될 수 있습니다.

## 다이렉트 메모리 (Direct Memory)

다이렉트 메모리는 JVM의 메모리 관리 영역(힙, 스택 등) 바깥, 즉 **운영체제(OS)가 직접 관리하는 네이티브 메모리 영역**을 말합니다. 이는 Java의 NIO (New I/O) 클래스인 `ByteBuffer`를 통해 사용할 수 있습니다.

다이렉트 메모리의 주된 사용 목적은 I/O 성능 향상입니다.

일반적인 힙 메모리(`ByteBuffer.allocate()`)를 사용해 파일이나 네트워크 소켓에서 데이터를 읽고 쓰는 경우, 데이터는 다음과 같은 비효율적인 과정을 거칩니다.

- 힙 버퍼 사용 시: `[I/O 장치] ↔ [네이티브 버퍼] ↔ [JVM 힙 버퍼]`
  - OS 커널은 I/O 작업을 위해 네이티브 메모리 버퍼를 사용합니다.
  - 따라서 JVM 힙에 있는 데이터를 I/O 하려면, 중간에 네이티브 버퍼로 데이터를 복사하는 과정이 추가로 필요합니다. 이 복사 과정이 성능 저하의 원인이 됩니다.
- 다이렉트 버퍼(`ByteBuffer.allocateDirect()`)는 이러한 데이터 복사 과정을 생략하여 성능을 높입니다.
  - 다이렉트 버퍼 사용 시: `[I/O 장치] ↔ [다이렉트 메모리 버퍼]`
    - 버퍼 자체가 네이티브 메모리에 생성되므로, JVM 힙을 거치지 않고 바로 I/O 작업을 수행할 수 있습니다.
