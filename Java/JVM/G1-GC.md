# G1 GC에 대해 설명해보기

## 기초 개념

### G1 GC의 등장 배경과 목적 - 왜 G1이 개발되었고, 어떤 문제를 해결하려고 했는지

G1 GC 이전의 CMS는 동시 수행을 통해 STW 시간을 줄이려 했습니다. 그러다보니 다음과 같은 '성능과 확장성 문제', '메모리 관리 문제'가 발생했습니다.

1. **성능과 확장성 문제**
   1. 동시 수행으로 인하여 사용자 스레드의 CPU 자원을 빼앗아 전반적인 성능 저하를 일으켰습니다.
   2. 대용량 힙(4GB 이상)에서 성능이 급격히 저하되어 현대적인 대용량 메모리 환경에 부적합했습니다.
   3. Full GC 발생 시 전체 힙을 대상으로 하다 보니 힙 크기에 비례하여 STW 시간이 길어졌습니다.
2. **메모리 관리 문제**
   1. 마크-스윕 방식으로 인한 메모리 단편화가 심각했습니다.
   2. 동시 수행 중에 생성된 부유 쓰레기는 다음 GC 사이클까지 처리되지 못했습니다.
   3. 동시 모드 실패가 발생하면 전체 힙을 대상으로 하는 Serial Old GC로 fallback되어 매우 긴 STW를 유발했습니다.

이러한 문제들을 해결하기 위해 G1 GC는 다음과 같은 목표로 개발되었습니다.

1. **예측 가능한 저지연 실현**
   1. 사용자가 설정한 목표 puase time(기본 200ms) 내에서 GC를 완료하는 것을 최우선 목표로 했습니다.
   2. 힙 크기와 무관하게 일정한 STW 시간을 보장하여 대용량 힙 환경에서도 안정적인 성능을 제공합니다.
2. **효율적인 메모리 관리**
   1. Region 기반 힙 구조를 통해 전체 힙이 아닌 일부 영역만 선택적으로 수집합니다.
   2. Compaction을 통해 메모리 단편화 문제를 해결했습니다.
   3. 수집 효율이 높은 Region을 우선적으로 선택하는 **Garbage First** 전략을 사용합니다.
3. **확장성과 실용성**
   1. 멀티코어 환경에서 병렬 처리를 통해 성능을 극대화했습니다.
   2. 복잡한 튜닝 없이도 대부분의 상황에서 안정적인 성능을 제공하도록 설계되었습니다.

#### CMS가 대용량 힙에서 성능이 급격히 저하되는 원인

- 표시 단계의 시간
  - CMS의 GC 단계 중 '동시 표시' 단계는 전체 힙을 순회하면서 도달가능한 객체들을 마킹합니다.
  - 힙이 클수록 순회해야 할 객체의 수가 많아져 표시 시간이 선형적으로 증가합니다.
  - 특히 최초 표시와 재표시 단계에서 STW 시간이 힙 크기에 비례해서 길어집니다.
- 쓸기 단계의 부담
  - 쓸기 단계에서도 전체 힙을 스캔해야 하므로 힙이 클수록 오래 걸립니다.
  - 메모리 단편화가 심할수록 free block들을 관리하는 오버헤드도 증가합니다.
- Full GC의 치명적 영향
  - 동시 모드 실패(Concurrent Mode Failure) 발생 시 Serial Old GC로 fallback되는데, 이때 처음부터 다시 전체 힙을 단일 스레드로 처리합니다.

#### Serial Old GC

- JVM에서 가장 기본적이고 오래된 구세대용 가비지 컬렉터입니다. 'Serial'이라는 이름에서 알 수 있듯이 단일 스레드로 동작하는 GC입니다.
- 마크-스윕-컴팩트 알고리즘을 사용합니다.
- 특징
  - GC 동안 모든 사용자 스레드가 완전히 정지됩니다.
  - 단일 스레드로 전체 구세대를 순차적으로 처리합니다.
  - 메모리를 정리하고 압축하므로 메모리 효율성은 좋습니다.

### G1의 메모리 구조 - Region 기반 힙 구조와 기존 GC와의 차이점

- 기존 GC들의 구조적 특징
  - 기존 GC는 고정된 크기와 위치를 가진 영역들로 구성됩니다.
  - 신세대 크기가 고정되어 있어 유연성이 떨어집니다.
- G1 GC의 Region의 구조적 특징
  - Region은 동일한 크기(1MB ~ 32MB)로 나뉩니다. 힙 크기에 따라 자동으로 결정됩니다.
  - Region은 에덴 공간, 생존자 공간, 구세대 공간, 거대 공간(Humongous Region), 빈 공간(Empty Region)의 역할을 수행합니다.
    - Humongous Region: 큰 객체(Region 크기의 50% 이상)를 위한 특별 영역
    - Empty Region: 아직 할당되지 않은 대기 상태 영역
  - 각 Region은 한 번에 하나의 역할만 수행합니다.

### G1의 세대별 수집 방식 - Young Generation과 Old Generation 처리 방식

G1 GC는 세대별로 처리 방식이 다르지 않습니다.

이름에서 알 수 있듯이 'Garbage First' 전략이기 때문에 사용자가 설정한 정지 시간 내에 처리할 수 있는 한도 내에서 회수 효과가 가장 큰 리전부터 회수합니다.

단지 차이가 있다면 최초 표시 단계에서 마이너 GC가 함께 실행이 되고, 이 마이너 GC의 대상은 모든 에덴 리전, 생존자 리전입니다.

구세대 리전과 거대 리전은 Mixed GC에서 처리됩니다. 이때는 모든 에덴 리전, 생존자 리전과 선별된 구세대 리전, 거대 리전이 대상이 됩니다.

## 핵심 메커니즘

### Remembered Set의 역할 - 참조 관계 추적과 성능 최적화

RSet은 다른 리전에서 해당 리전으로 향하는 참조를 추적하기 위한 데이터 구조입니다.

각 리전은 자신만의 RSet을 가집니다. G1 GC는 이를 통해 수집 시 불필요한 전체 힙 스캔을 피할 수 있습니다.

그리고 RSet은 카드테이블과 쓰기 장벽의 협조로 구성되며 참조 추적은 다음과 같은 단계를 거칩니다.

1. 참조 할당 발생
2. 쓰기 장벽(Write Barrier)이 참조가 발생한 카드를 Dirty로 마킹
3. GC 사이클 중 RSet 업데이트 단계에서 Dirty 카드를 스캔하여 실제 참조(다른 리전에서 이 리전을 가리키는 포인터)를 발견
4. 발견된 참조 정보를 RSet에 기록 (즉, 해당 참조가 들어오는 리전의 RSet에 해당 참조가 발생하는 카드 정보를 추가)
5. RSet 업데이트가 완료된 후 카드를 Clean으로 변경

카드 테이블은 힙 메모리를 일정한 크기(보통 512바이트)의 카드로 나누고 각 카드의 상태를 추적하는 데이터 구조입니다. 해당 카드 안의 객체 중 하나라도 세대 간 참조가 있다면 해당 카드는 더럽혀졌다(dirty)라고 카드 테이블에 1로 표시합니다.

### Collection Set 선택 전략 - 어떤 Region을 언제 수집할지 결정하는 방식

CSet은 GC 단계 중 이번 GC 주기에서 수집할 리전들의 집합을 말합니다. G1 GC의 핵심 특징 중 하나는 전체 힙을 한꺼번에 수집하지 않고, 일부 리전만 선택적으로 수집한다는 점입니다.

Young(에덴, 생존자) 리전은 항상 CSet에 포함됩니다. 이 리전들은 새 객체가 할당되는 곳이고 회수 효율이 가장 높기 때문입니다. 그리고 일부 Old 리전들을 함께 수집합니다. 이것이 Mixed GC입니다. Mixed GC는 여러 번(기본 8번) 반복해서 수행되고 점진적으로 Old 리전을 정리합니다.

Mixed GC가 발생하는 조건은 다음과 같습니다.

- 힙 사용률이 특정 임계치(기본 45%)를 초과한 경우
- 동시 표시가 완료된 상태

수집할 Old 리전을 선택하는 방식은 다음과 같습니다.

- 동시 표시 후 각 Old 리전의 Live 데이터 비율을 계산
- 각 리전의 Garbage Ratio(비사용 공간 비율)를 기준으로 수집 우선순위를 매김
- 각 리전을 수집하는 데 걸릴 예상 시간을 고려하여 pause time 내에 최대한 많은 가비지를 수집할 수 있는 리전을 선택

## 고급 주제

### G1의 Stop-the-World 시간 제어 - 목표 pause time 달성 방법

G1 GC의 가장 큰 특징이자 핵심 목표 중 하나는 예측 가능한 Pause Time을 제공하는 것입니다. G1은 애플리케이션의 응답 시간에 민감한 환경에서 사용될 수 있도록 사용자가 설정한 최대 Pause Time 목표를 달성하기 위해 노력합니다.

G1이 STW 시간을 제어하고 목표 Pause Time을 달성하는 주요 방법은 다음과 같습니다.

1. 힙을 Region으로 분할
   1. 전체 힙을 스캔하거나 회수하는 것보다 선택적으로 회수할 리전을 선택하여 훨씬 짧은 시간에 부분적인 GC를 수행
2. CSet 동적 구성
   1. Young Region은 항상 CSet에 포함, Old Region은 회수율이 높은 리전부터 CSet에 포함될 우선 순위를 가짐
3. 동시성 처리
   1. GC 작업을 애플리케이션 스레드와 동시에 실행하여 STW 시간을 최소화
4. 단계별 STW 최소화
   1. 최초 표시: GC루트에서 직접 참조되는 객체들을 마킹하는 단계. 마이너 GC가 실행될 때 함께 실행되어 STW 최소화
   2. 재표시: SATB 쓰기 장벽이 기록한 정보를 처리하는 단계. 비교적 짧은 STW 구간
   3. 복사 및 청소: 통계 데이터를 기초로 회수 계획을 수립. 설정된 Pause Time 목표에 맞게 복사할 객체의 양을 선택. 다수의 GC 스레드가 병렬로 처리.

즉, G1 GC는 힙을 Region으로 분할하고 동시 표시를 통해 대부분의 작업을 백그라운드에서 처리하며, 설정된 Pause Time 목표 내에서 최대한 효율적으로 가비지를 수집할 수 있도록 CSet을 동적으로 조절합니다.

### SATB(Snapshot-At-The-Beginning) 알고리즘 - 동시성 처리를 위한 핵심 기법

#### 동시성 문제

SATB는 동시성 가비지 컬렉터에서 객체 생존 여부를 판단하고 동시성 문제를 해결하기 위해 사용되는 핵심 알고리즘입니다. GC 사이클이 시작되는 시점의 힙 스냅샷을 기반으로 객체의 생존 여부를 판단합니다.

동시성 가비지 컬렉터는 애플리케이션 스레드가 동작하는 동안 GC 스레드가 동시에 힙을 스캔하고 가비지를 수집합니다. 이때 다음과 같은 동시성 문제(Tracing Problem)가 발생할 수 있습니다.

1. 객체 누락(Lost Object): GC 스레드가 객체를 스캔하고 지나간 후에 애플리케이션 스레드가 그 객체에 대한 유일한 참조를 끊고 동시에 다른 객체가 그 객체를 참조하게 되는 경우, GC는 그 객체가 죽었다고 오인하여 회수할 수 있습니다. (삼색 표기법 참조)
2. 부유 가비지(Floating Garbage): GC 스캔 중에 살아있는 객체로 판단되었지만 GC 스캔이 완료되기 전에 애플리케이션 스레드에 의해 더이상 참조되지 않게 된 객체입니다. 이 객체는 다음 GC 사이클에서나 회수될 수 있으므로 이번 GC 사이클에서는 힙 공간을 불필요하게 점유하게 됩니다.

SATB는 이 중 객체 누락 문제를 방지하는 데 초점을 맞춥니다. 객체 누락은 심각한 오류(Crash)로 이어질 수 있으므로 이를 방지하는 것이 최우선 목표입니다. Floating Garbage는 메모리 낭비로 이어지지만 프로그램 실행에 치명적이지 않으며 다음 GC 사이클에 회수될 수 있습니다.

#### SATB 동작 원리

SATB는 GC 사이클 시작 시점의 힙 상태를 '스냅샷'으로 간주하고 이 스냅샷에 포함된 모든 살아있는 객체를 보존하려 합니다. 이를 위해 쓰기 장벽을 활용합니다.

1. **GC 사이클 시작(표시 단계 시작)**: GC는 현재 힙의 모든 GC 루트에서부터 그래프 탐색을 시작하여 도달가능한 객체들을 마킹합니다.
2. **쓰기 장벽**: 참조의 변화가 발생한 객체에 대한 변경을 기록합니다.
3. **재표시 단계**: 이 단계에서 SATB 쓰기장벽에 의해 기록된 객체들을 스캔하여 도달 가능 여부를 재확인합니다. 만약 도달 가능하다면 살아있는 것으로 표시합니다.

G1 GC에서는 SATB를 사용하여 동시 표시 단계에서 정확성을 모장합니다. 특히 G1은 리전이라는 개념을 사용하여 힙을 분할하기 때문에 다른 리전으로의 참조가 변경될 때 RSet을 업데이트하는 작업과 함께 SATB 쓰기 장벽이 동작하여 이전 참조를 기록합니다.

### Humongous Object 처리 - 큰 객체들을 어떻게 다루는지

### GC Roots로 선택될 수 있는 객체와 그 이유

## 추가 주제

### STW가 왜 꼭 필요한가? 없다면 어떻게 되는가?
