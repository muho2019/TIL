# G1 GC에 대해 설명해보기

## 기초 개념

### G1 GC의 등장 배경과 목적 - 왜 G1이 개발되었고, 어떤 문제를 해결하려고 했는지

G1 GC 이전의 CMS는 동시 수행을 통해 STW 시간을 줄이려 했습니다. 그러다보니 다음과 같은 '성능과 확장성 문제', '메모리 관리 문제'가 발생했습니다.

1. **성능과 확장성 문제**
   1. 동시 수행으로 인하여 사용자 스레드의 CPU 자원을 빼앗아 전반적인 성능 저하를 일으켰습니다.
   2. 대용량 힙(4GB 이상)에서 성능이 급격히 저하되어 현대적인 대용량 메모리 환경에 부적합했습니다.
   3. Full GC 발생 시 전체 힙을 대상으로 하다 보니 힙 크기에 비례하여 STW 시간이 길어졌습니다.
2. **메모리 관리 문제**
   1. 마크-스윕 방식으로 인한 메모리 단편화가 심각했습니다.
   2. 동시 수행 중에 생성된 부유 쓰레기는 다음 GC 사이클까지 처리되지 못했습니다.
   3. 동시 모드 실패가 발생하면 전체 힙을 대상으로 하는 Serial Old GC로 fallback되어 매우 긴 STW를 유발했습니다.

이러한 문제들을 해결하기 위해 G1 GC는 다음과 같은 목표로 개발되었습니다.

1. **예측 가능한 저지연 실현**
   1. 사용자가 설정한 목표 puase time(기본 200ms) 내에서 GC를 완료하는 것을 최우선 목표로 했습니다.
   2. 힙 크기와 무관하게 일정한 STW 시간을 보장하여 대용량 힙 환경에서도 안정적인 성능을 제공합니다.
2. **효율적인 메모리 관리**
   1. Region 기반 힙 구조를 통해 전체 힙이 아닌 일부 영역만 선택적으로 수집합니다.
   2. Compaction을 통해 메모리 단편화 문제를 해결했습니다.
   3. 수집 효율이 높은 Region을 우선적으로 선택하는 **Garbage First** 전략을 사용합니다.
3. **확장성과 실용성**
   1. 멀티코어 환경에서 병렬 처리를 통해 성능을 극대화했습니다.
   2. 복잡한 튜닝 없이도 대부분의 상황에서 안정적인 성능을 제공하도록 설계되었습니다.

### G1의 메모리 구조 - Region 기반 힙 구조와 기존 GC와의 차이점

### G1의 세대별 수집 방식 - Young Generation과 Old Generation 처리 방식

## 핵심 메커니즘

### Remembered Set의 역할 - 참조 관계 추적과 성능 최적화

### Collection Set 선택 전략 - 어떤 Region을 언제 수집할지 결정하는 방식

### Concurrent Marking 과정 - 백그라운드에서 진행되는 마킹 작업의 단계별 설명

### Mixed Collection의 동작 원리 - Young + Old Region 혼합 수집

## 고급 주제

### G1의 Stop-the-World 시간 제어 - 목표 pause time 달성 방법

### SATB(Snapshot-At-The-Beginning) 알고리즘 - 동시성 처리를 위한 핵심 기법

### Humongous Object 처리 - 큰 객체들을 어떻게 다루는지
