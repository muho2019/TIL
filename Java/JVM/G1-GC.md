# G1 GC에 대해 설명해보기

## 기초 개념

### G1 GC의 등장 배경과 목적 - 왜 G1이 개발되었고, 어떤 문제를 해결하려고 했는지

G1 GC 이전의 CMS는 동시 수행을 통해 STW 시간을 줄이려 했습니다. 그러다보니 다음과 같은 '성능과 확장성 문제', '메모리 관리 문제'가 발생했습니다.

1. **성능과 확장성 문제**
   1. 동시 수행으로 인하여 사용자 스레드의 CPU 자원을 빼앗아 전반적인 성능 저하를 일으켰습니다.
   2. 대용량 힙(4GB 이상)에서 성능이 급격히 저하되어 현대적인 대용량 메모리 환경에 부적합했습니다.
   3. Full GC 발생 시 전체 힙을 대상으로 하다 보니 힙 크기에 비례하여 STW 시간이 길어졌습니다.
2. **메모리 관리 문제**
   1. 마크-스윕 방식으로 인한 메모리 단편화가 심각했습니다.
   2. 동시 수행 중에 생성된 부유 쓰레기는 다음 GC 사이클까지 처리되지 못했습니다.
   3. 동시 모드 실패가 발생하면 전체 힙을 대상으로 하는 Serial Old GC로 fallback되어 매우 긴 STW를 유발했습니다.

이러한 문제들을 해결하기 위해 G1 GC는 다음과 같은 목표로 개발되었습니다.

1. **예측 가능한 저지연 실현**
   1. 사용자가 설정한 목표 puase time(기본 200ms) 내에서 GC를 완료하는 것을 최우선 목표로 했습니다.
   2. 힙 크기와 무관하게 일정한 STW 시간을 보장하여 대용량 힙 환경에서도 안정적인 성능을 제공합니다.
2. **효율적인 메모리 관리**
   1. Region 기반 힙 구조를 통해 전체 힙이 아닌 일부 영역만 선택적으로 수집합니다.
   2. Compaction을 통해 메모리 단편화 문제를 해결했습니다.
   3. 수집 효율이 높은 Region을 우선적으로 선택하는 **Garbage First** 전략을 사용합니다.
3. **확장성과 실용성**
   1. 멀티코어 환경에서 병렬 처리를 통해 성능을 극대화했습니다.
   2. 복잡한 튜닝 없이도 대부분의 상황에서 안정적인 성능을 제공하도록 설계되었습니다.

#### CMS가 대용량 힙에서 성능이 급격히 저하되는 원인

- 표시 단계의 시간
  - CMS의 GC 단계 중 '동시 표시' 단계는 전체 힙을 순회하면서 도달가능한 객체들을 마킹합니다.
  - 힙이 클수록 순회해야 할 객체의 수가 많아져 표시 시간이 선형적으로 증가합니다.
  - 특히 최초 표시와 재표시 단계에서 STW 시간이 힙 크기에 비례해서 길어집니다.
- 쓸기 단계의 부담
  - 쓸기 단계에서도 전체 힙을 스캔해야 하므로 힙이 클수록 오래 걸립니다.
  - 메모리 단편화가 심할수록 free block들을 관리하는 오버헤드도 증가합니다.
- Full GC의 치명적 영향
  - 동시 모드 실패(Concurrent Mode Failure) 발생 시 Serial Old GC로 fallback되는데, 이때 처음부터 다시 전체 힙을 단일 스레드로 처리합니다.

#### Serial Old GC

- JVM에서 가장 기본적이고 오래된 구세대용 가비지 컬렉터입니다. 'Serial'이라는 이름에서 알 수 있듯이 단일 스레드로 동작하는 GC입니다.
- 마크-스윕-컴팩트 알고리즘을 사용합니다.
- 특징
  - GC 동안 모든 사용자 스레드가 완전히 정지됩니다.
  - 단일 스레드로 전체 구세대를 순차적으로 처리합니다.
  - 메모리를 정리하고 압축하므로 메모리 효율성은 좋습니다.

### G1의 메모리 구조 - Region 기반 힙 구조와 기존 GC와의 차이점

- 기존 GC들의 구조적 특징
  - 기존 GC는 고정된 크기와 위치를 가진 영역들로 구성됩니다.
  - 신세대 크기가 고정되어 있어 유연성이 떨어집니다.
- G1 GC의 Region의 구조적 특징
  - Region은 동일한 크기(1MB ~ 32MB)로 나뉩니다. 힙 크기에 따라 자동으로 결정됩니다.
  - Region은 에덴 공간, 생존자 공간, 구세대 공간, 거대 공간(Humongous Region), 빈 공간(Empty Region)의 역할을 수행합니다.
    - Humongous Region: 큰 객체(Region 크기의 50% 이상)를 위한 특별 영역
    - Empty Region: 아직 할당되지 않은 대기 상태 영역
  - 각 Region은 한 번에 하나의 역할만 수행합니다.

### G1의 세대별 수집 방식 - Young Generation과 Old Generation 처리 방식

G1 GC는 세대별로 처리 방식이 다르지 않습니다.

이름에서 알 수 있듯이 'Garbage First' 전략이기 때문에 사용자가 설정한 정지 시간 내에 처리할 수 있는 한도 내에서 회수 효과가 가장 큰 리전부터 회수합니다.

단지 차이가 있다면 최초 표시 단계에서 마이너 GC가 함께 실행이 되고, 이 마이너 GC의 대상은 모든 에덴 리전, 생존자 리전입니다.

구세대 리전과 거대 리전은 Mixed GC에서 처리됩니다. 이때는 모든 에덴 리전, 생존자 리전과 선별된 구세대 리전, 거대 리전이 대상이 됩니다.

## 핵심 메커니즘

### Remembered Set의 역할 - 참조 관계 추적과 성능 최적화

RSet은 다른 리전에서 해당 리전으로 향하는 참조를 추적하기 위한 데이터 구조입니다.

각 리전은 자신만의 RSet을 가집니다. G1 GC는 이를 통해 수집 시 불필요한 전체 힙 스캔을 피할 수 있습니다.

그리고 RSet은 카드테이블과 쓰기 장벽의 협조로 구성되며 참조 추적은 다음과 같은 단계를 거칩니다.

1. 참조 할당 발생
2. 쓰기 장벽(Write Barrier)이 참조가 발생한 카드를 Dirty로 마킹
3. GC 사이클 중 RSet 업데이트 단계에서 Dirty 카드를 스캔하여 실제 참조(다른 리전에서 이 리전을 가리키는 포인터)를 발견
4. 발견된 참조 정보를 RSet에 기록 (즉, 해당 참조가 들어오는 리전의 RSet에 해당 참조가 발생하는 카드 정보를 추가)
5. RSet 업데이트가 완료된 후 카드를 Clean으로 변경

카드 테이블은 힙 메모리를 일정한 크기(보통 512바이트)의 카드로 나누고 각 카드의 상태를 추적하는 데이터 구조입니다. 해당 카드 안의 객체 중 하나라도 세대 간 참조가 있다면 해당 카드는 더럽혀졌다(dirty)라고 카드 테이블에 1로 표시합니다.

### Collection Set 선택 전략 - 어떤 Region을 언제 수집할지 결정하는 방식

CSet은 GC 단계 중 이번 GC 주기에서 수집할 리전들의 집합을 말합니다. G1 GC의 핵심 특징 중 하나는 전체 힙을 한꺼번에 수집하지 않고, 일부 리전만 선택적으로 수집한다는 점입니다.

Young(에덴, 생존자) 리전은 항상 CSet에 포함됩니다. 이 리전들은 새 객체가 할당되는 곳이고 회수 효율이 가장 높기 때문입니다. 그리고 일부 Old 리전들을 함께 수집합니다. 이것이 Mixed GC입니다. Mixed GC는 여러 번(기본 8번) 반복해서 수행되고 점진적으로 Old 리전을 정리합니다.

Mixed GC가 발생하는 조건은 다음과 같습니다.

- 힙 사용률이 특정 임계치(기본 45%)를 초과한 경우
- 동시 표시가 완료된 상태

수집할 Old 리전을 선택하는 방식은 다음과 같습니다.

- 동시 표시 후 각 Old 리전의 Live 데이터 비율을 계산
- 각 리전의 Garbage Ratio(비사용 공간 비율)를 기준으로 수집 우선순위를 매김
- 각 리전을 수집하는 데 걸릴 예상 시간을 고려하여 pause time 내에 최대한 많은 가비지를 수집할 수 있는 리전을 선택

## 고급 주제

### G1의 Stop-the-World 시간 제어 - 목표 pause time 달성 방법

### SATB(Snapshot-At-The-Beginning) 알고리즘 - 동시성 처리를 위한 핵심 기법

### Humongous Object 처리 - 큰 객체들을 어떻게 다루는지

### GC Roots로 선택될 수 있는 객체와 그 이유

## 추가 주제

### STW가 왜 꼭 필요한가? 없다면 어떻게 되는가?
