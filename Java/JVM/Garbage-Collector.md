# 가비지 컬렉터

- [가비지 컬렉터](#가비지-컬렉터)
  - [가비지 컬렉션을 이해해야 하는 이유](#가비지-컬렉션을-이해해야-하는-이유)
  - [가비지 컬렉션의 대상 영역](#가비지-컬렉션의-대상-영역)
  - [도달 가능성 분석 알고리즘](#도달-가능성-분석-알고리즘)
    - [동작 원리](#동작-원리)
    - [GC Roots가 될 수 있는 객체들](#gc-roots가-될-수-있는-객체들)
  - [참조의 구분](#참조의-구분)
  - [메서드 영역 회수하기](#메서드-영역-회수하기)
    - [다 쓴 클래스인지 판단하는 조건](#다-쓴-클래스인지-판단하는-조건)
  - [세대 단위 컬렉션 이론](#세대-단위-컬렉션-이론)
    - [세대별 가설](#세대별-가설)
    - [세대별 메모리 구조](#세대별-메모리-구조)
    - [다양한 GC 방식](#다양한-gc-방식)
  - [마크-스윕 알고리즘](#마크-스윕-알고리즘)
    - [동작 과정](#동작-과정)
    - [단점](#단점)
  - [마크-카피 알고리즘](#마크-카피-알고리즘)
    - [동작 과정](#동작-과정-1)
    - [장점](#장점)
    - [단점](#단점-1)
  - [아펠 스타일 컬렉션](#아펠-스타일-컬렉션)
    - [메모리 구조](#메모리-구조)
    - [동작 과정](#동작-과정-2)
    - [장점](#장점-1)
  - [마크-컴팩트 알고리즘](#마크-컴팩트-알고리즘)
    - [동작 과정](#동작-과정-3)
    - [장점](#장점-2)
    - [단점](#단점-2)
  - [루트 노드 열거 (Root Node Enumeration)](#루트-노드-열거-root-node-enumeration)
  - [OopMap (Ordinary Object Pointer Map)](#oopmap-ordinary-object-pointer-map)
  - [안전 지점 (Safe Point)](#안전-지점-safe-point)
  - [안전 지역 (Safe Region)](#안전-지역-safe-region)
  - [기억 집합 (Remembered Set)](#기억-집합-remembered-set)
  - [카드 테이블 (Card Table)](#카드-테이블-card-table)
  - [쓰기 장벽 (Write Barrier)](#쓰기-장벽-write-barrier)
  - [동시 접근 가능성 분석](#동시-접근-가능성-분석)
    - [도달 가능성 분석 알고리즘의 기본 원리](#도달-가능성-분석-알고리즘의-기본-원리)
    - [삼색 표시 기법 (Tri-Color Marking)](#삼색-표시-기법-tri-color-marking)
    - [동시 실행 시 발생하는 문제점](#동시-실행-시-발생하는-문제점)
      - [이상적인 상황](#이상적인-상황)
      - [동시 실행 시 문제 발생](#동시-실행-시-문제-발생)
      - [죽은 객체의 잘못된 생존 표시](#죽은-객체의-잘못된-생존-표시)
      - [살아있는 객체의 잘못된 죽음 표시](#살아있는-객체의-잘못된-죽음-표시)
    - [객체 사라짐 문제 (Object Disappearance Problem)](#객체-사라짐-문제-object-disappearance-problem)
      - [문제 발생 조건](#문제-발생-조건)
      - [해결 방안](#해결-방안)

## 가비지 컬렉션을 이해해야 하는 이유

가비지 컬렉터가 자동으로 메모리 회수를 해주는데 우리는 왜 가비지 컬렉션과 메모리 할당에 대해 이해해야 할까요? 그건 바로, 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면, 이 '자동화된' 기술을 적절히 모니터링하고 조율할 수 있어야 하기 때문입니다.

## 가비지 컬렉션의 대상 영역

Thread private한 메모리 영역(PC 레지스터, 스택, 네이티브 메서드 스택)은 스레드와 함께 생성되고 소멸됩니다. 따라서 스레드가 종료되면 자연스럽게 회수됩니다.

반면에 **힙과 메서드 영역**은 그렇지 않습니다. 이 영역들은 프로그램 실행 중 동적으로 메모리가 할당되고 회수되어야 하므로, 가비지 컬렉터는 바로 이 영역들을 관리하는 데 집중합니다.

## 도달 가능성 분석 알고리즘

도달 가능성 분석(Reachability Analysis)은 현재 주류 JVM들이 사용하는 가비지 컬렉션 판단 알고리즘입니다.

### 동작 원리

1. GC Roots라고 불리는 객체들을 루트 집합으로 설정합니다.
2. 이 루트들로부터 시작하여 참조 체인을 따라 도달할 수 있는 모든 객체를 찾습니다.
3. 도달할 수 없는 객체들은 가비지로 판단하여 회수합니다.

### GC Roots가 될 수 있는 객체들

- 가상 머신 스택의 지역 변수 테이블에서 참조하는 객체
- 메서드 영역에서 클래스 정적 필드로 참조하는 객체
- 메서드 영역에서 상수가 참조하는 객체
- 네이티브 메서드 스택에서 참조하는 객체
- JVM 내부 참조(기본 타입에 대응하는 Class 객체, 상주 예외 객체 등)

## 참조의 구분

JDK 1.2 이후 참조의 개념이 확장되어 네 가지 유형으로 분류됩니다.

- **강한 참조 (Strong Reference)**: `Object obj = new Object()`처럼 프로그램 코드에서 참조를 할당하는 것을 말합니다. 강한 참조가 존재하는 한 가비지 컬렉터는 절대 해당 객체를 회수하지 않습니다.
- **부드러운 참조 (Soft Reference)**: `SoftReference` 클래스로 구현되어 있습니다. 메모리 공간이 충분할 때는 가비지 컬렉터가 회수하지 않지만, 메모리가 부족해지면 회수합니다. 메모리 민감한 캐시 구현에 유용합니다.
- **약한 참조 (Weak Reference)**: `WeakReference` 클래스로 구현되어 있습니다. 다음 가비지 컬렉션이 발생하면 메모리 부족 여부와 관계없이 회수됩니다.
- **유령 참조 (Phantom Reference)**: 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능합니다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서입니다. `PhantomReference` 클래스로 구현되어 있습니다.

## 메서드 영역 회수하기

메서드 영역(또는 메타스페이스)의 가비지 컬렉션은 힙 영역보다 복잡합니다. 주로 **상수 풀 회수**와 **타입 언로딩**(클래스 회수)을 수행합니다.

상수 풀 회수는 비교적 간단하지만, 클래스 회수는 매우 까다로운 조건들을 만족해야 합니다. 클래스 회수의 효과도 미미하여 많은 경우 비활성화하거나 제한적으로만 사용됩니다.

### 다 쓴 클래스인지 판단하는 조건

세 가지 조건을 모두 만족해야 클래스를 회수할 수 있습니다.

- 클래스의 인스턴스가 모두 회수되었다. 즉, 힙에 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 `java.lang.Class` 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

## 세대 단위 컬렉션 이론

### 세대별 가설

1. **약한 세대 가설 (Weak Generational Hypothesis)**: 대다수 객체는 일찍 죽는다.
2. **강한 세대 가설 (Strong Generational Hypothesis)**: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
3. **세대 간 참조 가설 (Intergenerational Reference Hypothesis)**: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

### 세대별 메모리 구조

힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당합니다. 여기서 나이란 가비지 컬렉션에서 살아남은 횟수를 말합니다.

- **신세대 (Young Generation)**: 새로 생성된 객체들이 저장되는 영역
- **구세대 (Old Generation)**: 여러 번의 GC에서 살아남은 객체들이 저장되는 영역

### 다양한 GC 방식

- **부분 GC**: 힙의 일부만 회수하는 가비지 컬렉션
  - **마이너 GC (Minor GC)**: 신세대만 대상으로 하는 가비지 컬렉션
  - **메이저 GC (Major GC)**: 구세대만 대상으로 하는 가비지 컬렉션
  - **혼합 GC (Mixed GC)**: 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션
- **전체 GC (Full GC)**: 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

## 마크-스윕 알고리즘

가장 기초적인 가비지 컬렉션 알고리즘으로, 두 단계로 나뉩니다.

### 동작 과정

1. **마크 단계**: 도달 가능성 분석을 통해 회수할 객체들을 마킹합니다.
2. **스윕 단계**: 마킹된 객체들을 일괄적으로 회수합니다.

### 단점

- **효율성 문제**: 두 단계 모두 전체 힙을 스캔해야 하므로 시간이 많이 걸립니다.
- **메모리 단편화**: 회수 후 메모리가 불연속적으로 분포하여 큰 객체 할당이 어려워집니다.
- **Stop-the-World**: 마킹 과정에서 객체 참조 관계 변경을 방지하기 위해 애플리케이션을 일시 중단해야 합니다.

## 마크-카피 알고리즘

메모리 단편화 문제를 해결하기 위해 고안된 알고리즘입니다.

### 동작 과정

1. 메모리를 두 개의 동일한 크기 영역으로 나눕니다.
2. 한 영역에서만 객체를 할당하고 사용합니다.
3. 가비지 컬렉션 시, 살아있는 객체들을 다른 영역으로 복사합니다.
4. 기존 영역을 완전히 비웁니다.
5. 두 영역의 역할을 바꿉니다.

### 장점

- **메모리 단편화 해결**: 복사 과정에서 객체들이 연속적으로 배치됩니다.
- **빠른 할당**: 포인터 이동만으로 메모리 할당이 가능합니다.

### 단점

- **메모리 사용 효율성**: 실제 사용 가능한 메모리가 절반으로 줄어듭니다.
- **객체 생존율이 높을 때 비효율적**: 많은 객체를 복사해야 합니다.

## 아펠 스타일 컬렉션

마크-카피 알고리즘의 메모리 낭비 문제를 개선한 방식입니다.

### 메모리 구조

신세대를 세 영역으로 나눕니다.

- **에덴(Eden) 영역**: 새로운 객체가 할당되는 영역 (전체의 80%)
- **생존자(Survivor) 영역 2개**: 살아남은 객체들이 복사되는 영역 (각각 전체의 10%)

### 동작 과정

1. 새 객체는 에덴 영역에 할당됩니다.
2. 에덴 영역이 가득 차면 마이너 GC가 발생합니다.
3. 에덴과 사용 중인 생존자 영역의 살아있는 객체들을 비어있는 생존자 영역으로 복사합니다.
4. 복사된 객체들의 나이를 1 증가시킵니다.
5. 나이가 임계값에 도달한 객체들은 구세대로 승격됩니다.

### 장점

- **메모리 효율성**: 전체 메모리의 90%를 활용할 수 있습니다.
- **세대별 특성 활용**: 신세대 객체의 높은 사망률을 효과적으로 활용합니다.

## 마크-컴팩트 알고리즘

구세대 영역에 적합한 알고리즘으로, 마크-스윕의 단편화 문제를 해결합니다.

### 동작 과정

1. **마크 단계**: 살아있는 객체들을 마킹합니다.
2. **컴팩트 단계**: 살아있는 객체들을 메모리의 한쪽 끝으로 이동시킵니다.
3. **스윕 단계**: 경계 밖의 메모리를 정리합니다.

### 장점

- **메모리 단편화 해결**: 객체들이 연속적으로 배치됩니다.
- **메모리 효율성**: 복사 알고리즘과 달리 전체 메모리를 활용할 수 있습니다.

### 단점

- **이동 비용**: 살아있는 객체들을 이동시키는 과정이 필요합니다.
- **참조 업데이트**: 객체 이동 후 모든 참조를 업데이트해야 합니다.
- **Stop-the-World**: 마크-카피보다 일시 중단 시간이 길어질 수 있습니다.

## 루트 노드 열거 (Root Node Enumeration)

루트 노드 열거란 도달 가능성 분석 알고리즘에서 GC 루트 집합으로부터 참조 체인을 찾는 작업을 의미합니다.

- 반드시 일관성이 보장되는 스냅숏 상태에서 수행해야 합니다
- 루트 노드들의 참조 관계가 변하지 않아야 합니다
- 이 조건을 지키지 못하면 분석 결과를 신뢰할 수 없습니다

## OopMap (Ordinary Object Pointer Map)

OopMap은 객체 참조가 저장된 위치를 알아낼 때 사용하는 데이터 구조입니다.

- 핫스팟 JVM이 GC 루트들을 빠르고 정확하게 열거할 수 있도록 지원
- 메모리의 어느 위치에 객체 참조(Object Reference)가 저장되어 있는지 기록
- 가비지 컬렉션 시 루트 스캐닝 시간을 대폭 단축
- 컴파일 시점에 생성되어 런타임 오버헤드 최소화

## 안전 지점 (Safe Point)

핫스팟 JVM은 OopMap을 모든 명령어 각각에 생성하지 않습니다. 그 대신 안전 지점이라고 하는 특정한 위치에만 기록합니다.

- 가비지 컬렉터는 사용자 프로그램이 안전 지점에 도달할 때까지는 절대 멈춰 세우지 않습니다
- 안전 지점에서는 모든 스레드의 상태가 일관성을 유지합니다
- 참조 관계가 변하지 않는 상태를 보장합니다

**설정 시 고려사항**

- 너무 적게 설정: 컬렉터가 너무 오래 기다리게 됨
- 너무 많이 설정: 런타임 메모리 부하가 지나치게 커짐
- 적절한 균형점 찾기가 중요

**안전 지점 도달 방법**

- 선점형 중단(Preemptive Suspension): GC가 모든 스레드를 강제로 중단 (사용하지 않음)
- 자발적 중단(Voluntary Suspension): 각 스레드가 안전 지점에서 폴링(Polling)하여 자발적으로 중단

## 안전 지역 (Safe Region)

안전 지역은 일정 코드 영역에서는 참조 관계가 변하지 않음을 보장합니다.

- 안전 지역 안이라면 어디서든 가비지 컬렉션을 시작해도 무방합니다
- 안전 지점을 확장한 개념이라고 할 수 있습니다
- 스레드가 블록된 상태에서도 안전하게 GC 수행 가능

**필요성**

- 스레드가 Sleep 상태이거나 Block 상태일 때 안전 지점에 도달할 수 없는 문제 해결
- 네이티브 코드 실행 중일 때의 GC 수행 문제 해결

**동작 방식**

- 스레드가 안전 지역에 진입할 때 표시
- GC 발생 시 안전 지역에 있는 스레드는 즉시 참여 가능
- 스레드가 안전 지역을 떠날 때 GC 완료 여부 확인

## 기억 집합 (Remembered Set)

기억 집합은 세대별 가비지 컬렉션에서 **세대간 참조 문제를 해결하기 위한 핵심 데이터 구조**입니다.

**세대간 참조 문제**

- 구세대 객체가 신세대 객체를 참조하는 경우 발생
- 신세대만 GC할 때 구세대의 모든 객체를 스캔해야 하는 비효율성
- 이는 세대별 GC의 성능 이점을 크게 감소시킴

**기억 집합의 역할**

- 구세대에서 신세대로의 모든 참조 정보를 기록
- 신세대 GC 시 전체 구세대 스캔을 방지
- 참조 관계가 변경될 때마다 업데이트

**구현 방식**

기억 집합은 다양한 방식으로 구현될 수 있습니다.

- 비트맵 (Bit Map): 각 메모리 주소에 대해 1비트로 참조 여부 표시
- 객체 배열 (Object Array): 참조하는 객체들의 배열로 저장
- **해시 테이블 (Hash Table)**: 키-값 쌍으로 참조 정보 저장 (**G1에서 사용**)

**정확도에 따른 분류**

- 정확한 기억 집합: 참조하는 정확한 객체나 포인터 기록
- 부정확한 기억 집합: 참조가 있는 메모리 영역만 기록 (카드 테이블 방식)

## 카드 테이블 (Card Table)

카드 테이블은 기억 집합의 가장 일반적인 구현 방식으로, 부정확한 기억 집합의 대표적인 예입니다.

**기본 구조**

- 구세대를 512바이트 크기의 카드로 분할
- 각 카드당 1바이트의 엔트리로 상태 표시
- 카드 내에 신세대 참조가 있으면 해당 카드를 **더티**(Dirty)로 표시

**카드 상태**

- 깨끗한 카드 (Clean Card): 신세대 참조가 없는 카드
- 더티 카드 (Dirty Card): 신세대 참조가 있는 카드

**동작 방식**

- 구세대 객체가 신세대 객체를 참조할 때 해당 카드를 더티로 표시
- 신세대 GC 발생 시 더티 카드만 스캔
- GC 완료 후 스캔한 카드들을 깨끗한 상태로 초기화

**장점**

- 메모리 오버헤드가 적음: 전체 힙 크기의 약 1/512 수준
- 빠른 업데이트: 단순한 바이트 쓰기 연산
- 효율적인 스캔: 더티 카드만 선별적으로 처리

**단점**

- 부정확성: 카드 내 모든 객체를 스캔해야 함 (실제 참조가 없어도)
- 거짓 양성: 참조가 삭제되어도 카드는 더티 상태 유지 가능

## 쓰기 장벽 (Write Barrier)

쓰기 장벽은 객체 참조가 변경될 때 **기억 집합을 업데이트하기 위한 메커니즘**입니다.

**기본 개념**

- 참조 필드 쓰기 연산을 가로채는 AOP(Aspect-Oriented Programming) 방식
- 참조 변경 시 추가적인 동작을 수행하여 메타데이터 업데이트
- JIT 컴파일러가 코드에 자동으로 삽입

**쓰기 장벽의 유형**

1. **사전 쓰기 장벽 (Pre-Write Barrier)**

- 참조 변경 이전에 실행
- 기존 참조 값을 기록
- **SATB**(Snapshot-At-The-Beginning) 방식에서 사용
- **G1 GC**에서 동시 마킹 중 참조 변경 추적

2. **사후 쓰기 장벽 (Post-Write Barrier)**

- 참조 변경 이후에 실행
- 새로운 참조 값을 기록
- **카드 테이블 업데이트에 주로 사용**
- 세대간 참조 추적

**성능 최적화 기법**

1. 조건부 실행

- 실제로 필요한 경우에만 쓰기 장벽 실행
- 세대간 참조가 아닌 경우 스킵

2. 배치 처리

- 여러 쓰기 장벽 동작을 큐에 모아서 배치 처리
- 동기화 오버헤드 감소

3. 하드웨어 지원

- 현대 프로세서의 메모리 보호 기능 활용
- 페이지 단위 보호를 통한 효율적인 추적

**쓰기 장벽의 오버헤드**

- 일반적으로 5-15%의 성능 오버헤드 발생
- 참조 쓰기가 빈번한 애플리케이션에서 더 큰 영향
- 최적화 기법 적용으로 오버헤드 최소화 가능

## 동시 접근 가능성 분석

### 도달 가능성 분석 알고리즘의 기본 원리

주류 가비지 컬렉터들은 기본적으로 **도달 가능성 분석 알고리즘**(Reachability Analysis Algorithm)을 사용하여 객체의 생존 여부를 판단합니다. 이 알고리즘은 일관성이 보장되는 스냅숏 상태에서 전체 과정을 진행해야 하므로, 분석 과정 동안 사용자 스레드는 일시 정지 상태를 유지해야 합니다.

### 삼색 표시 기법 (Tri-Color Marking)

사용자 스레드의 일시 정지 문제를 해결하거나 줄이기 위해서는 먼저 일관성이 보장되는 스냅숏 상태에서 객체 그래프를 탐색하는 이유를 파악해야 합니다. **삼색 표시 기법**(Tri-Color Marking) 통해 이 문제를 명확히 설명할 수 있습니다.

객체 그래프를 탐색하는 과정에서 마주치는 객체들을 "방문한 객체인가"라는 조건에 따라 다음과 같이 세 가지 색으로 분류합니다

- **흰색 객체 (White Objects)**
  - 정의: 가비지 컬렉터가 방문한 적 없는 객체
  - 의미: 분석을 마친 뒤에도 흰색인 객체는 도달 불가능함을 의미하여 가비지 컬렉션 대상이 됩니다
- **검은색 객체 (Black Objects)**
  - 정의: 가비지 컬렉터가 방문한 적이 있으며, 이 객체가 가리키는 모든 참조를 스캔 완료한 객체
  - 의미: 스캔이 완료되었고 확실히 생존함을 의미합니다
  - 제약 사항: 검은색 객체가 흰색 객체를 직접 가리키는 것은 불가능하며, 회색 객체를 거쳐야 합니다
- **회색 객체 (Gray Objects)**
  - 정의: 가비지 컬렉터가 방문한 적은 있으나, 이 객체가 가리키는 참조 중 스캔을 완료하지 않은 참조가 존재하는 객체
  - 역할: 검은색 객체와 흰색 객체 사이의 중간 상태로, 추가 스캔이 필요한 객체입니다

### 동시 실행 시 발생하는 문제점

#### 이상적인 상황

객체 그래프를 탐색하는 과정에서 사용자 스레드들이 멈춘 채로 컬렉터의 GC 스레드만 실행된다면 아무 문제가 없습니다.

#### 동시 실행 시 문제 발생

하지만 사용자 스레드와 컬렉터가 동시에 실행되면서 컬렉터가 객체 그래프에 색을 칠해 가는 도중에 사용자 스레드가 참조 관계를 변경하면 두 가지 결과가 발생할 수 있습니다.

#### 죽은 객체의 잘못된 생존 표시

- **현상**: 실제로는 죽은 객체를 살았다고 잘못 표시
- **영향**: 좋지 않은 일이지만 감내할 수 있는 수준입니다. 컬렉터의 눈을 피해 남아있는 쓰레기가 생기지만, 다음 번 가비지 컬렉션 때 회수할 수 있습니다.

#### 살아있는 객체의 잘못된 죽음 표시

- **현상**: 실제로는 살아있는 객체를 죽었다고 표시
- **영향**: 매우 치명적이며 프로그램 오류로 이어질 수 있습니다.

### 객체 사라짐 문제 (Object Disappearance Problem)

#### 문제 발생 조건

다음 두 조건이 동시에 만족될 때 **객체 사라짐 문제**(Object Disappearance Problem)가 발생합니다. 즉, 검은색이었어야 할 객체가 실수로 흰색으로 표시되는 현상입니다

- **새로운 참조 추가**: 사용자 스레드가 흰색 객체로의 새로운 참조를 검은색 객체에 추가
- **기존 참조 삭제**: 사용자 스레드가 회색 객체에서 흰색 객체로의 직간접적인 참조를 삭제

#### 해결 방안

**동시 스캔(Concurrent Scanning)** 도중 객체 사라짐 문제를 해결하려면 위의 두 조건 중 하나만 깨뜨리면 됩니다. 이는 다음과 같은 방법으로 구현할 수 있습니다.

- 증분 업데이트(Incremental Update): 검은색 객체가 흰색 객체를 참조할 때 검은색을 회색으로 변경
- 시작 단계 스냅숏(SATB, Snapshot-At-The-Beginning): 회색에서 흰색으로의 참조가 삭제될 때 흰색을 회색으로 변경
