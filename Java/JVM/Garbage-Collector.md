# 가비지 컬렉터

- [가비지 컬렉터](#가비지-컬렉터)
  - [가비지 컬렉션을 이해해야 하는 이유](#가비지-컬렉션을-이해해야-하는-이유)
  - [가비지 컬렉션의 대상 영역](#가비지-컬렉션의-대상-영역)
  - [도달 가능성 분석 알고리즘](#도달-가능성-분석-알고리즘)
    - [동작 원리](#동작-원리)
    - [GC Roots가 될 수 있는 객체들](#gc-roots가-될-수-있는-객체들)
  - [참조의 구분](#참조의-구분)
  - [메서드 영역 회수하기](#메서드-영역-회수하기)
    - [다 쓴 클래스인지 판단하는 조건](#다-쓴-클래스인지-판단하는-조건)
  - [세대 단위 컬렉션 이론](#세대-단위-컬렉션-이론)
    - [세대별 가설](#세대별-가설)
    - [세대별 메모리 구조](#세대별-메모리-구조)
    - [다양한 GC 방식](#다양한-gc-방식)
  - [마크-스윕 알고리즘](#마크-스윕-알고리즘)
    - [동작 과정](#동작-과정)
    - [단점](#단점)
  - [마크-카피 알고리즘](#마크-카피-알고리즘)
    - [동작 과정](#동작-과정-1)
    - [장점](#장점)
    - [단점](#단점-1)
  - [아펠 스타일 컬렉션](#아펠-스타일-컬렉션)
    - [메모리 구조](#메모리-구조)
    - [동작 과정](#동작-과정-2)
    - [장점](#장점-1)
  - [마크-컴팩트 알고리즘](#마크-컴팩트-알고리즘)
    - [동작 과정](#동작-과정-3)
    - [장점](#장점-2)
    - [단점](#단점-2)
  - [동시 접근 가능성 분석](#동시-접근-가능성-분석)
    - [도달 가능성 분석 알고리즘의 기본 원리](#도달-가능성-분석-알고리즘의-기본-원리)
    - [GC 과정과 성능 영향](#gc-과정과-성능-영향)
      - [루트 노드 열거와 객체 그래프 탐색](#루트-노드-열거와-객체-그래프-탐색)
      - [표시 단계의 중요성](#표시-단계의-중요성)
    - [삼색 표시 기법 (Tri-Color Marking)](#삼색-표시-기법-tri-color-marking)
    - [동시 실행 시 발생하는 문제점](#동시-실행-시-발생하는-문제점)
      - [이상적인 상황](#이상적인-상황)
      - [동시 실행 시 문제 발생](#동시-실행-시-문제-발생)
      - [죽은 객체의 잘못된 생존 표시](#죽은-객체의-잘못된-생존-표시)
      - [살아있는 객체의 잘못된 죽음 표시](#살아있는-객체의-잘못된-죽음-표시)
    - [객체 사라짐 문제 (Object Disappearance Problem)](#객체-사라짐-문제-object-disappearance-problem)
      - [문제 발생 조건](#문제-발생-조건)
      - [해결 방안](#해결-방안)

## 가비지 컬렉션을 이해해야 하는 이유

가비지 컬렉터가 자동으로 메모리 회수를 해주는데 우리는 왜 가비지 컬렉션과 메모리 할당에 대해 이해해야 할까요? 그건 바로, 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면, 이 '자동화된' 기술을 적절히 모니터링하고 조율할 수 있어야 하기 때문입니다.

## 가비지 컬렉션의 대상 영역

Thread private한 메모리 영역(PC 레지스터, 스택, 네이티브 메서드 스택)은 스레드와 함께 생성되고 소멸됩니다. 따라서 스레드가 종료되면 자연스럽게 회수됩니다.

반면에 **힙과 메서드 영역**은 그렇지 않습니다. 이 영역들은 프로그램 실행 중 동적으로 메모리가 할당되고 회수되어야 하므로, 가비지 컬렉터는 바로 이 영역들을 관리하는 데 집중합니다.

## 도달 가능성 분석 알고리즘

도달 가능성 분석(Reachability Analysis)은 현재 주류 JVM들이 사용하는 가비지 컬렉션 판단 알고리즘입니다.

### 동작 원리

1. GC Roots라고 불리는 객체들을 루트 집합으로 설정합니다.
2. 이 루트들로부터 시작하여 참조 체인을 따라 도달할 수 있는 모든 객체를 찾습니다.
3. 도달할 수 없는 객체들은 가비지로 판단하여 회수합니다.

### GC Roots가 될 수 있는 객체들

- 가상 머신 스택의 지역 변수 테이블에서 참조하는 객체
- 메서드 영역에서 클래스 정적 필드로 참조하는 객체
- 메서드 영역에서 상수가 참조하는 객체
- 네이티브 메서드 스택에서 참조하는 객체
- JVM 내부 참조(기본 타입에 대응하는 Class 객체, 상주 예외 객체 등)

## 참조의 구분

JDK 1.2 이후 참조의 개념이 확장되어 네 가지 유형으로 분류됩니다.

- **강한 참조 (Strong Reference)**: `Object obj = new Object()`처럼 프로그램 코드에서 참조를 할당하는 것을 말합니다. 강한 참조가 존재하는 한 가비지 컬렉터는 절대 해당 객체를 회수하지 않습니다.
- **부드러운 참조 (Soft Reference)**: `SoftReference` 클래스로 구현되어 있습니다. 메모리 공간이 충분할 때는 가비지 컬렉터가 회수하지 않지만, 메모리가 부족해지면 회수합니다. 메모리 민감한 캐시 구현에 유용합니다.
- **약한 참조 (Weak Reference)**: `WeakReference` 클래스로 구현되어 있습니다. 다음 가비지 컬렉션이 발생하면 메모리 부족 여부와 관계없이 회수됩니다.
- **유령 참조 (Phantom Reference)**: 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능합니다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서입니다. `PhantomReference` 클래스로 구현되어 있습니다.

## 메서드 영역 회수하기

메서드 영역(또는 메타스페이스)의 가비지 컬렉션은 힙 영역보다 복잡합니다. 주로 **상수 풀 회수**와 **타입 언로딩**(클래스 회수)을 수행합니다.

상수 풀 회수는 비교적 간단하지만, 클래스 회수는 매우 까다로운 조건들을 만족해야 합니다. 클래스 회수의 효과도 미미하여 많은 경우 비활성화하거나 제한적으로만 사용됩니다.

### 다 쓴 클래스인지 판단하는 조건

세 가지 조건을 모두 만족해야 클래스를 회수할 수 있습니다.

- 클래스의 인스턴스가 모두 회수되었다. 즉, 힙에 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 `java.lang.Class` 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

## 세대 단위 컬렉션 이론

### 세대별 가설

1. **약한 세대 가설 (Weak Generational Hypothesis)**: 대다수 객체는 일찍 죽는다.
2. **강한 세대 가설 (Strong Generational Hypothesis)**: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
3. **세대 간 참조 가설 (Intergenerational Reference Hypothesis)**: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

### 세대별 메모리 구조

힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당합니다. 여기서 나이란 가비지 컬렉션에서 살아남은 횟수를 말합니다.

- **신세대 (Young Generation)**: 새로 생성된 객체들이 저장되는 영역
- **구세대 (Old Generation)**: 여러 번의 GC에서 살아남은 객체들이 저장되는 영역

### 다양한 GC 방식

- **부분 GC**: 힙의 일부만 회수하는 가비지 컬렉션
  - **마이너 GC (Minor GC)**: 신세대만 대상으로 하는 가비지 컬렉션
  - **메이저 GC (Major GC)**: 구세대만 대상으로 하는 가비지 컬렉션
  - **혼합 GC (Mixed GC)**: 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션
- **전체 GC (Full GC)**: 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

## 마크-스윕 알고리즘

가장 기초적인 가비지 컬렉션 알고리즘으로, 두 단계로 나뉩니다.

### 동작 과정

1. **마크 단계**: 도달 가능성 분석을 통해 회수할 객체들을 마킹합니다.
2. **스윕 단계**: 마킹된 객체들을 일괄적으로 회수합니다.

### 단점

- **효율성 문제**: 두 단계 모두 전체 힙을 스캔해야 하므로 시간이 많이 걸립니다.
- **메모리 단편화**: 회수 후 메모리가 불연속적으로 분포하여 큰 객체 할당이 어려워집니다.
- **Stop-the-World**: 마킹 과정에서 객체 참조 관계 변경을 방지하기 위해 애플리케이션을 일시 중단해야 합니다.

## 마크-카피 알고리즘

메모리 단편화 문제를 해결하기 위해 고안된 알고리즘입니다.

### 동작 과정

1. 메모리를 두 개의 동일한 크기 영역으로 나눕니다.
2. 한 영역에서만 객체를 할당하고 사용합니다.
3. 가비지 컬렉션 시, 살아있는 객체들을 다른 영역으로 복사합니다.
4. 기존 영역을 완전히 비웁니다.
5. 두 영역의 역할을 바꿉니다.

### 장점

- **메모리 단편화 해결**: 복사 과정에서 객체들이 연속적으로 배치됩니다.
- **빠른 할당**: 포인터 이동만으로 메모리 할당이 가능합니다.

### 단점

- **메모리 사용 효율성**: 실제 사용 가능한 메모리가 절반으로 줄어듭니다.
- **객체 생존율이 높을 때 비효율적**: 많은 객체를 복사해야 합니다.

## 아펠 스타일 컬렉션

마크-카피 알고리즘의 메모리 낭비 문제를 개선한 방식입니다.

### 메모리 구조

신세대를 세 영역으로 나눕니다.

- **에덴(Eden) 영역**: 새로운 객체가 할당되는 영역 (전체의 80%)
- **생존자(Survivor) 영역 2개**: 살아남은 객체들이 복사되는 영역 (각각 전체의 10%)

### 동작 과정

1. 새 객체는 에덴 영역에 할당됩니다.
2. 에덴 영역이 가득 차면 마이너 GC가 발생합니다.
3. 에덴과 사용 중인 생존자 영역의 살아있는 객체들을 비어있는 생존자 영역으로 복사합니다.
4. 복사된 객체들의 나이를 1 증가시킵니다.
5. 나이가 임계값에 도달한 객체들은 구세대로 승격됩니다.

### 장점

- **메모리 효율성**: 전체 메모리의 90%를 활용할 수 있습니다.
- **세대별 특성 활용**: 신세대 객체의 높은 사망률을 효과적으로 활용합니다.

## 마크-컴팩트 알고리즘

구세대 영역에 적합한 알고리즘으로, 마크-스윕의 단편화 문제를 해결합니다.

### 동작 과정

1. **마크 단계**: 살아있는 객체들을 마킹합니다.
2. **컴팩트 단계**: 살아있는 객체들을 메모리의 한쪽 끝으로 이동시킵니다.
3. **스윕 단계**: 경계 밖의 메모리를 정리합니다.

### 장점

- **메모리 단편화 해결**: 객체들이 연속적으로 배치됩니다.
- **메모리 효율성**: 복사 알고리즘과 달리 전체 메모리를 활용할 수 있습니다.

### 단점

- **이동 비용**: 살아있는 객체들을 이동시키는 과정이 필요합니다.
- **참조 업데이트**: 객체 이동 후 모든 참조를 업데이트해야 합니다.
- **Stop-the-World**: 마크-카피보다 일시 중단 시간이 길어질 수 있습니다.

## 동시 접근 가능성 분석

### 도달 가능성 분석 알고리즘의 기본 원리

주류 가비지 컬렉터들은 기본적으로 **도달 가능성 분석 알고리즘**(Reachability Analysis Algorithm)을 사용하여 객체의 생존 여부를 판단합니다. 이 알고리즘은 일관성이 보장되는 스냅숏 상태에서 전체 과정을 진행해야 하므로, 분석 과정 동안 사용자 스레드는 일시 정지 상태를 유지해야 합니다.

### GC 과정과 성능 영향

#### 루트 노드 열거와 객체 그래프 탐색

**루트 노드 열거**(Root Node Enumeration)가 완료되면, 가비지 컬렉터는 **GC 루트**(GC Root)로부터 객체 그래프를 탐색할 수 있습니다. 이 단계의 일시 정지 시간은 자바 힙 크기에 비례하여 증가합니다.

#### 표시 단계의 중요성

참조 관계를 추적하는 가비지 컬렉션 알고리즘들에는 공통적으로 **표시 단계**(Marking Phase)가 존재합니다. 이 단계의 일시 정지 시간을 줄일 수 있다면 거의 모든 컬렉터에 도움이 됩니다.

### 삼색 표시 기법 (Tri-Color Marking)

사용자 스레드의 일시 정지 문제를 해결하거나 줄이기 위해서는 먼저 일관성이 보장되는 스냅숏 상태에서 객체 그래프를 탐색하는 이유를 파악해야 합니다. **삼색 표시 기법**(Tri-Color Marking) 통해 이 문제를 명확히 설명할 수 있습니다.

객체 그래프를 탐색하는 과정에서 마주치는 객체들을 "방문한 객체인가"라는 조건에 따라 다음과 같이 세 가지 색으로 분류합니다

- **흰색 객체 (White Objects)**
  - 정의: 가비지 컬렉터가 방문한 적 없는 객체
  - 의미: 분석을 마친 뒤에도 흰색인 객체는 도달 불가능함을 의미하여 가비지 컬렉션 대상이 됩니다
- **검은색 객체 (Black Objects)**
  - 정의: 가비지 컬렉터가 방문한 적이 있으며, 이 객체가 가리키는 모든 참조를 스캔 완료한 객체
  - 의미: 스캔이 완료되었고 확실히 생존함을 의미합니다
  - 제약 사항: 검은색 객체가 흰색 객체를 직접 가리키는 것은 불가능하며, 회색 객체를 거쳐야 합니다
- **회색 객체 (Gray Objects)**
  - 정의: 가비지 컬렉터가 방문한 적은 있으나, 이 객체가 가리키는 참조 중 스캔을 완료하지 않은 참조가 존재하는 객체
  - 역할: 검은색 객체와 흰색 객체 사이의 중간 상태로, 추가 스캔이 필요한 객체입니다

### 동시 실행 시 발생하는 문제점

#### 이상적인 상황

객체 그래프를 탐색하는 과정에서 사용자 스레드들이 멈춘 채로 컬렉터의 GC 스레드만 실행된다면 아무 문제가 없습니다.

#### 동시 실행 시 문제 발생

하지만 사용자 스레드와 컬렉터가 동시에 실행되면서 컬렉터가 객체 그래프에 색을 칠해 가는 도중에 사용자 스레드가 참조 관계를 변경하면 두 가지 결과가 발생할 수 있습니다:

#### 죽은 객체의 잘못된 생존 표시

- **현상**: 실제로는 죽은 객체를 살았다고 잘못 표시
- **영향**: 좋지 않은 일이지만 감내할 수 있는 수준입니다. 컬렉터의 눈을 피해 남아있는 쓰레기가 생기지만, 다음 번 가비지 컬렉션 때 회수할 수 있습니다.

#### 살아있는 객체의 잘못된 죽음 표시

- **현상**: 실제로는 살아있는 객체를 죽었다고 표시
- **영향**: 매우 치명적이며 프로그램 오류로 이어질 수 있습니다.

### 객체 사라짐 문제 (Object Disappearance Problem)

#### 문제 발생 조건

다음 두 조건이 동시에 만족될 때 **객체 사라짐 문제**(Object Disappearance Problem)가 발생합니다. 즉, 검은색이었어야 할 객체가 실수로 흰색으로 표시되는 현상입니다

- **새로운 참조 추가**: 사용자 스레드가 흰색 객체로의 새로운 참조를 검은색 객체에 추가
- **기존 참조 삭제**: 사용자 스레드가 회색 객체에서 흰색 객체로의 직간접적인 참조를 삭제

#### 해결 방안

**동시 스캔(Concurrent Scanning)** 도중 객체 사라짐 문제를 해결하려면 위의 두 조건 중 하나만 깨뜨리면 됩니다. 이는 다음과 같은 방법으로 구현할 수 있습니다:

- 증분 업데이트(Incremental Update): 검은색 객체가 흰색 객체를 가리키는 새로운 참조를 기록
- 원시 스냅숏(SATB, Snapshot-At-The-Beginning): 회색 객체가 흰색 객체를 가리키는 참조 삭제를 기록
