# 가비지 컬렉터

- [가비지 컬렉터](#가비지-컬렉터)
  - [가비지 컬렉션을 이해해야 하는 이유](#가비지-컬렉션을-이해해야-하는-이유)
  - [가비지 컬렉션의 대상 영역](#가비지-컬렉션의-대상-영역)
  - [도달 가능성 분석 알고리즘](#도달-가능성-분석-알고리즘)
    - [동작 원리](#동작-원리)
    - [GC Roots가 될 수 있는 객체들](#gc-roots가-될-수-있는-객체들)
  - [참조의 구분](#참조의-구분)
  - [메서드 영역 회수하기](#메서드-영역-회수하기)
    - [다 쓴 클래스인지 판단하는 조건](#다-쓴-클래스인지-판단하는-조건)
  - [세대 단위 컬렉션 이론](#세대-단위-컬렉션-이론)
    - [세대별 가설](#세대별-가설)
    - [세대별 메모리 구조](#세대별-메모리-구조)
    - [다양한 GC 방식](#다양한-gc-방식)
  - [마크-스윕 알고리즘](#마크-스윕-알고리즘)
    - [동작 과정](#동작-과정)
    - [단점](#단점)
  - [마크-카피 알고리즘](#마크-카피-알고리즘)
    - [동작 과정](#동작-과정-1)
    - [장점](#장점)
    - [단점](#단점-1)
  - [아펠 스타일 컬렉션](#아펠-스타일-컬렉션)
    - [메모리 구조](#메모리-구조)
    - [동작 과정](#동작-과정-2)
    - [장점](#장점-1)
  - [마크-컴팩트 알고리즘](#마크-컴팩트-알고리즘)
    - [동작 과정](#동작-과정-3)
    - [장점](#장점-2)
    - [단점](#단점-2)

## 가비지 컬렉션을 이해해야 하는 이유

가비지 컬렉터가 자동으로 메모리 회수를 해주는데 우리는 왜 가비지 컬렉션과 메모리 할당에 대해 이해해야 할까요? 그건 바로, 다양한 메모리 오버플로와 누수 문제를 해결해야 하는 상황이나 더 높은 동시성을 달성하는 데 가비지 컬렉션이 방해가 되는 상황이 오면, 이 '자동화된' 기술을 적절히 모니터링하고 조율할 수 있어야 하기 때문입니다.

## 가비지 컬렉션의 대상 영역

Thread private한 메모리 영역(PC 레지스터, 스택, 네이티브 메서드 스택)은 스레드와 함께 생성되고 소멸됩니다. 따라서 스레드가 종료되면 자연스럽게 회수됩니다.

반면에 **힙과 메서드 영역**은 그렇지 않습니다. 이 영역들은 프로그램 실행 중 동적으로 메모리가 할당되고 회수되어야 하므로, 가비지 컬렉터는 바로 이 영역들을 관리하는 데 집중합니다.

## 도달 가능성 분석 알고리즘

도달 가능성 분석(Reachability Analysis)은 현재 주류 JVM들이 사용하는 가비지 컬렉션 판단 알고리즘입니다.

### 동작 원리

1. GC Roots라고 불리는 객체들을 루트 집합으로 설정합니다.
2. 이 루트들로부터 시작하여 참조 체인을 따라 도달할 수 있는 모든 객체를 찾습니다.
3. 도달할 수 없는 객체들은 가비지로 판단하여 회수합니다.

### GC Roots가 될 수 있는 객체들

- 가상 머신 스택의 지역 변수 테이블에서 참조하는 객체
- 메서드 영역에서 클래스 정적 필드로 참조하는 객체
- 메서드 영역에서 상수가 참조하는 객체
- 네이티브 메서드 스택에서 참조하는 객체
- JVM 내부 참조(기본 타입에 대응하는 Class 객체, 상주 예외 객체 등)

## 참조의 구분

JDK 1.2 이후 참조의 개념이 확장되어 네 가지 유형으로 분류됩니다.

- **강한 참조 (String Reference)**: `Object obj = new Object()`처럼 프로그램 코드에서 참조를 할당하는 것을 말합니다. 강한 참조가 존재하는 한 가비지 컬렉터는 절대 해당 객체를 회수하지 않습니다.
- **부드러운 참조 (Soft Reference)**: `SoftReference` 클래스로 구현되어 있습니다. 메모리 공간이 충분할 때는 가비지 컬렉터가 회수하지 않지만, 메모리가 부족해지면 회수합니다. 메모리 민감한 캐시 구현에 유용합니다.
- **약한 참조 (Weak Reference)**: `WeakReference` 클래스로 구현되어 있습니다. 다음 가비지 컬렉션이 발생하면 메모리 부족 여부와 관계없이 회수됩니다.
- **유령 참조 (Phantom Reference)**: 객체 수명에 아무런 영향을 주지 않으며, 유령 참조를 통해 객체 인스턴스를 가져오는 것마저 불가능합니다. 유령 참조를 거는 유일한 목적은 대상 객체가 회수될 때 알림을 받기 위해서입니다. `PhantomReference` 클래스로 구현되어 있습니다.

## 메서드 영역 회수하기

메서드 영역(또는 메타스페이스)의 가비지 컬렉션은 힙 영역보다 복잡합니다. 주로 **상수 풀 회수**와 **타입 언로딩**(클래스 회수)을 수행합니다.

상수 풀 회수는 비교적 간단하지만, 클래스 회수는 매우 까다로운 조건들을 만족해야 합니다. 클래스 회수의 효과도 미미하여 많은 경우 비활성화하거나 제한적으로만 사용됩니다.

### 다 쓴 클래스인지 판단하는 조건

세 가지 조건을 모두 만족해야 클래스를 회수할 수 있습니다.

- 클래스의 인스턴스가 모두 회수되었다. 즉, 힙에 해당 클래스와 하위 클래스의 인스턴스가 하나도 존재하지 않는다.
- 클래스를 읽어 들인 클래스 로더가 회수되었다.
- 이 클래스에 해당하는 `java.lang.Class` 객체를 아무 곳에서도 참조하지 않고 리플렉션 기능으로 이 클래스의 메서드를 이용하는 곳도 전혀 없다.

## 세대 단위 컬렉션 이론

### 세대별 가설

1. **약한 세대 가설 (Weak Generational Hypothesis)**: 대다수 객체는 일찍 죽는다.
2. **강한 세대 가설 (Strong Generational Hypothesis)**: 가비지 컬렉션 과정에서 살아남은 횟수가 늘어날수록 더 오래 살 가능성이 커진다.
3. **세대 간 참조 가설 (Intergenerational Reference Hypothesis)**: 세대 간 참조의 개수는 같은 세대 안에서의 참조보다 훨씬 적다.

### 세대별 메모리 구조

힙을 몇 개의 영역으로 나누고 객체들을 나이에 따라 각기 다른 영역에 할당합니다. 여기서 나이란 가비지 컬렉션에서 살아남은 횟수를 말합니다.

- **신세대 (Young Generation)**: 새로 생성된 객체들이 저장되는 영역
- **구세대 (Old Generation)**: 여러 번의 GC에서 살아남은 객체들이 저장되는 영역

### 다양한 GC 방식

- **부분 GC**: 힙의 일부만 회수하는 가비지 컬렉션
  - **마이너 GC (Minor GC)**: 신세대만 대상으로 하는 가비지 컬렉션
  - **메이저 GC (Major GC)**: 구세대만 대상으로 하는 가비지 컬렉션
  - **혼합 GC (Mixed GC)**: 신세대 전체와 구세대 일부를 대상으로 하는 가비지 컬렉션
- **전체 GC (Full GC)**: 자바 힙 전체와 메서드 영역까지 모두를 대상으로 하는 가비지 컬렉션

## 마크-스윕 알고리즘

가장 기초적인 가비지 컬렉션 알고리즘으로, 두 단계로 나뉩니다.

### 동작 과정

1. **마크 단계**: 도달 가능성 분석을 통해 회수할 객체들을 마킹합니다.
2. **스윕 단계**: 마킹된 객체들을 일괄적으로 회수합니다.

### 단점

- **효율성 문제**: 두 단계 모두 전체 힙을 스캔해야 하므로 시간이 많이 걸립니다.
- **메모리 단편화**: 회수 후 메모리가 불연속적으로 분포하여 큰 객체 할당이 어려워집니다.
- **Stop-the-World**: 마킹 과정에서 객체 참조 관계 변경을 방지하기 위해 애플리케이션을 일시 중단해야 합니다.

## 마크-카피 알고리즘

메모리 단편화 문제를 해결하기 위해 고안된 알고리즘입니다.

### 동작 과정

1. 메모리를 두 개의 동일한 크기 영역으로 나눕니다.
2. 한 영역에서만 객체를 할당하고 사용합니다.
3. 가비지 컬렉션 시, 살아있는 객체들을 다른 영역으로 복사합니다.
4. 기존 영역을 완전히 비웁니다.
5. 두 영역의 역할을 바꿉니다.

### 장점

- **메모리 단편화 해결**: 복사 과정에서 객체들이 연속적으로 배치됩니다.
- **빠른 할당**: 포인터 이동만으로 메모리 할당이 가능합니다.

### 단점

- **메모리 사용 효율성**: 실제 사용 가능한 메모리가 절반으로 줄어듭니다.
- **객체 생존율이 높을 때 비효율적**: 많은 객체를 복사해야 합니다.

## 아펠 스타일 컬렉션

마크-카피 알고리즘의 메모리 낭비 문제를 개선한 방식입니다.

### 메모리 구조

신세대를 세 영역으로 나눕니다.

- **에덴(Eden) 영역**: 새로운 객체가 할당되는 영역 (전체의 80%)
- **생존자(Survivor) 영역 2개**: 살아남은 객체들이 복사되는 영역 (각각 전체의 10%)

### 동작 과정

1. 새 객체는 에덴 영역에 할당됩니다.
2. 에덴 영역이 가득 차면 마이너 GC가 발생합니다.
3. 에덴과 사용 중인 생존자 영역의 살아있는 객체들을 비어있는 생존자 영역으로 복사합니다.
4. 복사된 객체들의 나이를 1 증가시킵니다.
5. 나이가 임계값에 도달한 객체들은 구세대로 승격됩니다.

### 장점

- **메모리 효율성**: 전체 메모리의 90%를 활용할 수 있습니다.
- **세대별 특성 활용**: 신세대 객체의 높은 사망률을 효과적으로 활용합니다.

## 마크-컴팩트 알고리즘

구세대 영역에 적합한 알고리즘으로, 마크-스윕의 단편화 문제를 해결합니다.

### 동작 과정

1. **마크 단계**: 살아있는 객체들을 마킹합니다.
2. **컴팩트 단계**: 살아있는 객체들을 메모리의 한쪽 끝으로 이동시킵니다.
3. **스윕 단계**: 경계 밖의 메모리를 정리합니다.

### 장점

- **메모리 단편화 해결**: 객체들이 연속적으로 배치됩니다.
- **메모리 효율성**: 복사 알고리즘과 달리 전체 메모리를 활용할 수 있습니다.

### 단점

- **이동 비용**: 살아있는 객체들을 이동시키는 과정이 필요합니다.
- **참조 업데이트**: 객체 이동 후 모든 참조를 업데이트해야 합니다.
- **Stop-the-World**: 마크-카피보다 일시 중단 시간이 길어질 수 있습니다.
