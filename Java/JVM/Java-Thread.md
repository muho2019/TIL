# 자바 스레드

## 프로세스와 스레드

스레드는 프로세스 내에서 실행되는 독립적인 실행 흐름입니다. 하나의 프로세스는 여러 개의 스레드를 가질 수 있으며 이를 통해 동시성(Concurrency)을 구현할 수 있습니다.

- **프로세스(Process)**: 운영체제에서 실행 중인 프로그램의 인스턴스
- **스레드(Thread)**: 프로세스를 구성하는 실행 단위
- 스레드들은 같은 프로세스 내에서 메모리 공간(Memory Space)을 공유합니다.

## 메모리 영역

### 프로세스의 메모리 영역

- **정적 할당 영역**
  - **코드 영역**: 텍스트 영역이라고도 불립니다. 읽기 전용이며 프로세스가 실행할 코드(기계어)가 저장됩니다.
  - **데이터 영역**: 전역 변수, 정적 변수, 초기화된 데이터가 저장됩니다.
- **동적 할당 영역**
  - **힙 영역**: 프로그래머가 런타임에 동적으로 할당하고 해제하는 메모리 영역입니다.
  - **스택 영역**: 함수 호출 시 지역 변수, 매개변수, 리턴 주소 등이 임시로 저장되는 영역입니다. 함수 호출이 종료되면 해당 데이터는 스택에서 제거됩니다.

### 스레드가 사용하는 메모리 영역

하나의 프로세스 내에 여러 스레드가 존재할 때, 이 스레드들은 프로세스의 메모리 공간을 공유하면서도 각자 독립적인 스택을 가집니다.

- **공유하는 영역**
  - 코드 영역
  - 데이터 영역
  - 힙 영역
- **독자적으로 가지는 영역**
  - **스택 영역**: 각 스레드는 함수 호출 정보, 지역 변수, 매개변수, 반환 주소 등을 저장하는 고유한 스택을 가집니다. 스택은 스레드마다 독립적으로 관리되므로, 한 스레드의 함수 호출이 다른 스레드의 스택에 영향을 주지 않습니다.
  - **PC(Program Counter) 레지스터**: 각 스레드는 자신이 다음에 실행할 명령어의 주소를 가리키는 프로그램 카운터를 독립적으로 가집니다. 이는 각 스레드가 고유한 실행 흐름을 유지할 수 있게 합니다.
  - **레지스터 세트**: PC 레지스터 외에도 스레드 실행에 필요한 다른 CPU 레지스터들(예: 스택 포인터, 일반 목적 레지스터)은 컨텍스트 스위칭 시 스레드마다 독립적으로 저장되고 복원됩니다.

## 스레드 종류

- 사용자 스레드
- 커널 스레드

### 사용자 스레드

커널의 지원없이 사용자 영역의 스레드 라이브러에 의해 생성되고 관리되는 스레드입니다. 커널은 이 스레드들의 존재를 알지 못합니다. 따라서 단일 제어 흐름을 가진 일반 프로세스처럼 취급합니다.

**특징**

- **관리 주체**: 사용자 수준 스레드 라이브러리
- **커널 독립적**: 스레드 생성, 소멸, 스케줄링, 동기화 등 스레드 관련 모든 작업이 사용자 영역에서 이루어지므로 커널 모드로의 전환(system call)이 필요 없습니다.
- **빠른 컨텍스트 스위칭**: 커널의 개입이 없으므로 스레드 간 전환(컨텍스트 스위칭)이 매우 빠릅니다.
- **높은 이식성**: 커널에 독립적으로 구현되므로 다양한 운영체제에서 동일한 스레드 라이브러리를 사용하여 작동할 수 있습니다.

**단점**

- **블로킹 문제**: 하나의 사용자 스레드가 I/O 작업 등으로 인해 블록(Blocked)되면 커널은 해당 프로세스 전체가 블록되었다고 인식하게 됩니다. 그로인해 프로세스 내의 다른 스레드들도 함께 블록되어 실행되지 못합니다.
- **멀티코어 활용 제한**: 커널은 단일 스레드로 인식하기 때문에, 여러 사용자 스레드를 동시에 여러 CPU 코어에 할당하여 병렬로 실행할 수 없습니다.

### 커널 스레드

운영체제 커널에 의해 직접 생성되고 관리되며 스케줄링되는 스레드입니다. 커널은 각 스레드의 존재를 인지하고 개별적으로 관리합니다.

**특징**

- **관리 주체**: 운영체제 커널
- **커널 의존적**: 스레드 생성, 소멸, 스케줄링 등 모든 스레드 작업에 커널의 개입(system call)이 필요합니다.
- **동시성 및 병렬성**: 한 스레드가 I/O 등으로 블록되더라도 커널은 해당 프로세스의 다른 스레드를 스케줄링하여 실행할 수 있습니다. 또한 멀티코어 시스템에서 여러 커널 스레드를 동시에 다른 코어에 할당하여 진정한 병렬 처리가 가능합니다.

**단점**

- **느린 컨텍스트 스위칭**: 스레드 작업 시마다 커널 모드로의 전환이 필요하므로 사용자 스레드에 비해 컨텍스트 스위칭 오버헤드가 크고 속도가 느립니다.
- **높은 자원 소모**: 각 커널 스레드는 커널이 관리하는 자체적인 자료 구조(TCB: Thread Control Block)를 가지므로 많은 수의 커널 스레드를 생성할 경우 시스템 자원 소모가 커집니다.

## 멀티스레딩

멀티스레딩은 하나의 프로세스가 여러 개의 스레드를 생성하여 각 스레드가 독립적인 실행 흐름을 가지고 동시에 작업을 수행하는 방식입니다.

**핵심 개념**

- **동시성(Concurrency)**: 여러 스레드가 번갈아 가며 실행되면서 동시에 진행되는 것처럼 보이는 상태입니다. 싱글 코어 CPU에서도 운영체제 스케줄러가 스레드 간 빠른 문맥 교환을 통해 이를 구현합니다.
- **병렬성(Parallelism)**: 여러 스레드가 실제로 동시에 여러 CPU 코어나 프로세서에서 실행되는 상태입니다. 멀티코어 CPU 환경에서만 가능합니다.

**장점**

- **응답성 향상**: 프로그램의 한 부분이 시간이 오래 걸리는 작업(예: 네트워크 통신, 파일 읽기/쓰기, 복잡한 계산 등)을 수행하더라도 다른 스레드는 사용자 인터페이스를 계속 업데이트하거나 다른 작업을 처리하여 프로그램이 멈춘 것처럼 보이지 않게 합니다. 이는 사용자 경험을 크게 향상시킵니다.
- **자원 활용 최적화**: 멀티코어 CPU 환경에서 각 코어가 다른 스레드를 실행하여 CPU 유휴 시간을 줄이고 전체적인 처리율을 높일 수 있습니다.
- **빠른 통신 및 데이터 공유**: 같은 프로세스 내의 스레드들은 프로세스의 메모리 공간을 공유합니다. 이로 인해 스레드 간에 데이터를 주고받는 것이 프로세스 간 통신보다 훨씬 빠르고 효율적입니다. 별도의 통신 메커니즘 없이 직접 메모리에 접근할 수 있습니다.

**단점**

- **동기화 문제**
  - **경쟁 조건(Race Condition)**: 여러 스레드가 공유 자원에 동시에 접근하여 값을 변경할 때, 어떤 스레드가 먼저 접근하느냐에 따라 결과가 달라지는 예측 불가능한 상황이 발생할 수 있습니다.
  - **데이터 불일치**: 경쟁 조건으로 인해 공유 자원의 데이터가 손상되거나 잘못된 상태가 될 수 있습니다.
  - **복잡성**: 이러한 문제를 해결하기 위해 락(Lock), 뮤텍스(Mutex), 세마포어(Semaphore), 모니터 등 복잡한 동기화 메커니즘을 사용해야 합니다. 이는 개발을 어렵게 하고 버그 발생 가능성을 높입니다.
- **데드락(Deadlock)**: 두 개 이상의 스레드가 서로가 점유하고 있는 자원을 얻기 위해 무한정 기다리는 교착 상태가 발생할 수 있습니다. 예를 들어, 스레드 A는 자원 X를 점유하고 자원 Y를 기다리고, 스레드 B는 자원 Y를 점유하고 자원 X를 기다리는 상황입니다. 데드락은 프로그램이 멈추는 치명적인 결과를 초래할 수 있습니다.
- **디버깅의 어려움**: 스레드의 실행 순서가 비결정적이기 때문에, 특정 조건에서만 발생하는 버그는 재현하기 어렵고 원인을 파악하기 매우 힘듭니다.
- **오버헤드**: 스레드를 생성하고 관리하는 데에도 시스템 자원이 소모됩니다. 너무 많은 스레드를 생성하면 오히려 컨텍스트 스위칭 오버헤드가 증가하여 전체적인 성능이 저하될 수 있습니다. 동기화 메커니즘 또한 추가적인 오버헤드를 발생시킵니다.

## 컨텍스트 스위칭 (Context Switching)

### 컨텍스트란?

컨텍스트는 프로세스 또는 스레드가 실행되기 위해 필요한 모든 상태 정보를 뜻합니다.

포함되는 정보는 다음과 같습니다.

- CPU 레지스터 값들
- 프로그램 카운터 (PC)
- 스택 포인터 (SP)
- 메모리 관리 정보
- I/O 상태 정보
- 기타 제어 정보

### 컨텍스트 스위칭이란?

컨텍스트 스위칭은 현재 실행 중인 스레드의 컨텍스트를 저장하고 다음에 실행할 스레드의 컨텍스트를 복원하는 과정을 뜻합니다.

## 자바에서의 스레드

자바는 언어 차원에서 멀티스레딩(Multithreading)을 지원합니다. JVM은 여러 스레드를 동시에 실행할 수 있으며 각 스레드는 독립적인 실행 스택(Execution Stack)을 가집니다.

- **메인 스레드(Main Thread)**: 모든 자바 프로그램은 main() 메서드에서 시작되는 메인 스레드를 가집니다.
- **데몬 스레드(Daemon Thread)**: 백그라운드에서 실행되는 보조 스레드
- **사용자 스레드(User Thread)**: 일반적인 작업을 수행하는 스레드

## 스레드 생성 방법

자바에서 스레드를 생성하는 방법은 주로 두 가지입니다.

- Thread 클래스 상속

```java
class MyThread extends Thread {
    @Override
    public void run() {
        // 스레드가 실행할 코드
    }
}

MyThread thread = new MyThread();
thread.start(); // 스레드 시작
```

- Runnable 인터페이스 구현

```java
class MyRunnable implements Runnable {
    @Override
    public void run() {
        // 스레드가 실행할 코드
    }
}

Thread thread = new Thread(new MyRunnable());
thread.start();
```

## 스레드 생명주기 (Thread Lifecycle)

스레드는 다음과 같은 상태들을 가집니다.

- **NEW**: 스레드가 생성되었지만 아직 시작되지 않은 상태
- **RUNNABLE**: 실행 중이거나 실행 준비가 된 상태
- **BLOCKED**: 동기화 블록에 진입하기 위해 대기 중인 상태
- **WAITING**: 다른 스레드의 특정 작업 완료를 무한정 기다리는 상태
- **TIMED_WAITING**: 지정된 시간 동안 대기하는 상태
- **TERMINATED**: 실행이 완료된 상태

## 스레드 동기화 (Thread Synchronization)

여러 스레드가 공유 자원(Shared Resources)에 동시에 접근할 때 발생할 수 있는 문제를 해결하기 위한 메커니즘입니다.

- 주요 동기화 방법
  - **synchronized 키워드**: 메서드나 블록에서 상호 배제(Mutual Exclusion) 제공
  - **Lock 인터페이스**: 더 세밀한 제어가 가능한 동기화 메커니즘
  - **volatile 키워드**: 변수의 가시성(Visibility) 보장
- 동기화 문제들
  - **경쟁 상태(Race Condition)**: 여러 스레드가 공유 자원에 동시 접근하여 예상치 못한 결과가 발생하는 상황
  - **데드락(Deadlock)**: 두 개 이상의 스레드가 서로의 자원을 기다리며 무한정 대기하는 상황

## 스레드 풀 (Thread Pool)

스레드 풀은 미리 생성된 스레드들을 재사용하여 성능을 향상시키는 패턴입니다. 프로그램이 작업을 요청할 때 스레드 풀은 새로운 스레드를 생성하지 않고 기존 스레드를 재사용하여 작업을 수행합니다. 작업이 완료되면 해당 스레드는 종료되지 않고 풀에 반환되어 다음 작업을 대기합니다. 이를 통해 스레드 생성/소멸에 따른 오버헤드를 줄이고 시스템 자원을 효율적으로 사용할 수 있습니다.

### 구성요소

- **워커 스레드(Worker Threads)**: 실제 작업을 수행하는 스레드의 집합입니다. 보통 프로그램 시작 시 미리 생성되어 대기 상태로 있습니다. 작업이 할당되면 실행하고 완료 후 다시 대기 상태로 돌아옵니다.
- **작업 큐(Task Queue)**: 처리해야 할 작업들이 대기하는 공간입니다. 작업은 FIFO(선입선출) 또는 우선순위에 따라 처리될 수 있습니다. 스레드가 바쁠 때 새로운 작업들이 여기서 대기하게 됩니다.
- **스레드 풀 관리자(Thread Pool Manager)**: 작업을 스레드에 할당하고 스레드의 상태를 관리하며 필요에 따라 스레드를 추가/제거하는 역할을 합니다.

### 장점

- **성능 최적화**: 스레드 생성/소멸 오버헤드를 줄여 응답 시간을 단축합니다.
- **자원 관리**: 시스템 자원을 효율적으로 사용하며 스레드 수를 제한해 과부하를 방지합니다.
- **확장성**: 작업량이 많아도 스레드 풀은 작업 큐를 통해 부하를 관리하며 스레드 수를 동적으로 조정할 수 있습니다.
- **간단한 관리**: 개발자가 스레드의 생명주기를 직접 관리할 필요 없이 작업만 제출하면 됩니다.

### 주의사항

- **과도한 스레드 수**: 스레드가 너무 많으면 컨텍스트 스위칭 오버헤드가 증가하고 성능이 저하됩니다.
- **작업 큐 오버플로우**: 큐 크기가 제한된 경우 작업이 너무 많으면 작업이 거부되거나 시스템이 느려질 수 있습니다.
- **데드락 위험**: 작업이 다른 작업의 완료를 기다리거나 스레드가 모두 블록되면 데드락이 발생할 수 있습니다.
- **스레드 누수**: 작업이 완료되지 않거나 스레드가 풀에 반환되지 않으면 자원이 고갈될 수 있습니다.

### 자바 코드

```java
ExecutorService executor = Executors.newFixedThreadPool(5);
executor.submit(() -> {
    // 작업 내용
});
executor.shutdown();
```

## 매핑 모델

매핑 종류는 다음과 같습니다.

- 1:1 매핑
- N:1 매핑
- M:N 매핑

### 1:1 매핑

대부분의 JVM에서 사용하는 매핑 방식입니다. 하나의 자바 스레드는 하나의 운영체제 스레드에 매핑됩니다.

**특징**

- 완전한 병렬 실행 가능
- 운영체제 스케줄러가 직접 관리

### N:1 매핑

여러 자바 스레드가 하나의 운영체제 스레드를 공유하는 방식입니다.

**특징**

- JVM이 내부적으로 스레드 전환 관리
- 진정한 병렬 실행 불가능

### M:N 매핑

여러 개의 자바 스레드와 여러 개의 운영체제 스레드를 중간 스케줄러가 동적으로 매핑 관리하는 방식입니다. Go 언어의 goroutine과 자바 21의 가상 스레드가 이러한 매핑 방식을 사용합니다.

**특징**

- 중간 스케줄러가 동적으로 매핑 관리
- 복잡하지만 유연함

## 운영체제의 스레드와 자바의 스레드 관계

자바 스레드는 JVM이라는 중간층을 통해 운영체제 스레드를 추상화한 것입니다. 즉, 자바 개발자가 사용하는 Thread 객체는 실제로는 운영체제의 네이티브 스레드와 연결되어 있습니다.

### 자바 스레드 코드가 실행될 때

```java
Thread javaThread = new Thread(() -> {
    System.out.println("Hello from Java thread");
});
javaThread.start();
```

위의 코드가 실행될 때 내부적으로 일어나는 일은 다음과 같습니다.

1. 자바 Thread 객체 생성
   1. JVM 힙에 Thread 인스턴스 생성
   2. 아직 운영체제 커널 스레드와 연결되지 않음
2. start() 메서드 호출
   1. JVM이 운영체제에게 새 스레드 생성 요청
   2. 운영체제가 실제 커널 스레드 생성
   3. JVM이 자바 스레드와 운영체제 스레드 연결
3. 매핑 테이블 등록
4. run() 메서드 실행
   1. 운영체제 스레드에서 JVM 바이트코드 해석 실행
