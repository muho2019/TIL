# JVM에서의 객체

JVM 메모리에서 객체가 만들어지는 시점부터, 저장되는 상세 구조, 그리고 접근하는 방식까지 알아보겠습니다. 설명은 가장 보편적인 HotSpot VM과 힙 메모리 영역을 기준으로 합니다.

## 1. 객체의 생성 과정

Java 코드에서 객체 생성은 `new` 키워드 단 하나로 이루어지지만 JVM 내부에서는 다음과 같이 여러 단계를 거쳐 객체가 생성됩니다. (여기서는 일반 Java 객체를 기준으로 합니다.)

1. **클래스 로딩 확인**: `new` 명령어를 만나면 해당 클래스를 가리키는 **심벌 참조**(Symbolic Reference)를 확인하고 이 클래스가 메모리(메서드 영역)에 로드되었는지 확인합니다. 로드되지 않았다면 클래스 로딩 과정을 먼저 수행합니다.
2. **메모리 할당**: 클래스 정보가 있으므로 객체에 필요한 메모리 크기가 확정됩니다. 이 크기만큼 힙 영역에서 메모리를 할당합니다. 이때 가비지 컬렉터(GC)의 압축(Compaction) 여부에 따라 할당 방식이 나뉩니다.
   - **포인터 밀치기(Bump the pointer)**: GC가 압축을 지원하여 사용중인 메모리와 여유 공간이 나뉘어 있을 때 사용됩니다. 단순히 여유 공간의 시작을 가리키는 포인터를 객체 크기만큼 이동시키는 빠른 방식입니다.
   - **여유 목록(Free list)**: 메모리가 파편화되어 있을 때 사용됩니다. JVM이 관리하는 여유 메모리 블록 리스트를 뒤져서 적절한 크기의 공간을 찾아 할당합니다.
3. **동시성 문제 해결**: 객체 생성은 매우 빈번하므로 멀티스레드 환경에서 메모리 할당 시 경합이 발생할 수 있습니다. JVM은 다음 두 가지 방식으로 이 문제를 해결합니다.
   - **CAS(Compare And Swap)**: 메모리 할당에 실패할 경우, CAS와 같은 동기화 기법을 통해 재시도하여 원자성을 보장합니다.
   - **TLAB(Thread-Local Allocation Buffer)**: (주로 사용되는 방식) 각 스레드에 힙의 Eden 영역 내에 작은 전용 버퍼를 미리 할당해 줍니다. 스레드는 이 버퍼 안에서 경합없이 자유롭게 객체를 할당하고 버퍼가 소진되면 새로운 TLAB를 동기화 과정을 거쳐 할당받습니다.
4. **메모리 0으로 초기화**: 할당된 메모리 공간을 모두 0(또는 `null`, `false`)으로 초기화합니다. 이 덕분에 개발자는 필드를 초기화하지 않아도 기본값을 갖는다고 보장받을 수 있습니다. (TLAB 사용 시에는 TLAB를 할당받을 때 이 작업이 미리 수행될 수 있습니다.)
5. **객체 헤더(Object Header) 설정**: 메모리 영역에 객체 헤더 정보를 설정합니다. 여기에는 객체가 어떤 클래스의 인스턴스인지(메타데이터 주소), 객체의 해시코드, GC 연령, 락(Lock) 상태 등의 정보가 포함됩니다.
6. 생성자 `<init>` 호출: JVM 관점에서는 5단계까지 끝나면 객체 생성이 완료됩니다. 하지만 Java 코드 관점에서는 마지막으로 객체의 생성자(`<init>` 메서드)가 호출되어야 합니다. 이 단계를 통해 개발자가 정의한 초기화 코드가 실행되고 비로소 완벽하게 사용 가능한 객체가 탄생합니다.

## 2. 객체의 메모리 구조

힙에 저장된 객체는 일반적으로 **객체 해더**, **인스턴스 데이터**, **패딩** 세 부분으로 구성됩니다.

### 2.1 객체 헤더(Object Header)

객체 헤더는 객체의 "신분증"과 같은 메타데이터를 담습니다. 그리고 그 데이터는 두 유형이 있습니다.

- **마크 워드(Mark Word)**: 객체의 해시코드, GC 연령, 락 상태 플래그, 스레드가 점유하고 있는 락들 등의 런타임 데이터를 저장합니다.
- **클래스 워드(Klass Word)**: 객체의 클래스의 메타데이터(메서드 영역에 있음)를 가리키는 클래스 포인터가 저장됩니다. 또한 객체가 배열인 경우 배열의 길이도 저장됩니다.

### 2.2 인스턴스 데이터 (Instance Data)

객체가 실제로 담고 있는 정보로, 프로그램 코드에서 정의한 다양한 타입의 필드와 부모 클래스로부터 상속받은 모든 필드가 이 부분에 기록됩니다.

- **저장 순서**: HotSpot VM은 기본적으로 `long/double`, `int`, `short/char`, `byte/boolean`, `객체 포인터` 순으로 할당합니다. 길이가 같은 필드끼리 모여 저장되며 부모 클래스의 필드가 자식 클래스의 필드보다 앞에 배치됩니다.
  - 추가적으로 `-XX:FieldsAllocationStyle` 옵션과 자바 소스 코드에서 필드를 정의한 순서에 따라 달라집니다.
- **공간 최적화**: `+XX:CompactFields` 옵션(기본값 true)이 활성화되면 하위 클래스의 짧은 필드들이 상위 클래스 필드 사이의 빈 공간에 끼워 넣어질 수 있어 공간을 절약합니다.

### 2.3 패딩 (Padding)

패딩은 **객체의 전체 크기를 8바이트의 배수로 맞추기 위해 존재**하며 특별한 의미는 없습니다. HotSpot VM의 자동 메모리 관리 시스템에서 객체의 시작 주소는 반드시 8바이트의 배수여야 하기 때문입니다. 객체 헤더는 정확히 8바이트의 정수배가 되도록 잘 설계되어 있고, 인스턴스 데이터가 8바이트의 배수가 아닐 경우에만 패딩으로 채우게 됩니다.

## 3. 객체에 접근하기

JVM 명세는 객체 접근 방식을 규정하지 않았기 때문에 가상 머신 구현에서 구현하기 나름입니다.

- **핸들(Handle) 방식**
  - 힙에 **핸들 저장용 풀**이 별도로 존재하며 참조 변수는 객체의 핸들 주소를 가리킵니다.
  - **장점**: GC 과정에서 객체가 이동해도 참조 자체는 수정할 필요 없이 핸들 내의 포인터만 변경하면 되므로 **안정적**입니다.
- **다이렉트 포인터(Direct Pointer) 방식**
  - **HotSpot VM의 기본 방식**이며 참조 변수가 객체의 실제 주소를 바로 저장합니다.
  - **장점**: 핸들을 경유하는 오버헤드가 없어 **속도가 빠릅니다**.
