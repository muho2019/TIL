# JVM에서의 객체

JVM 메모리에서 객체가 만들어지는 시점부터, 저장되는 상세 구조, 그리고 접근하는 방식까지 알아보겠습니다. 설명은 가장 보편적인 HotSpot VM과 힙 메모리 영역을 기준으로 합니다.

## 1. 객체의 생성 과정

Java 코드에서 객체 생성은 `new` 키워드 단 하나로 이루어지지만 JVM 내부에서는 다음과 같이 여러 단계를 거쳐 객체가 생성됩니다. (여기서는 일반 Java 객체를 기준으로 합니다.)

1. **클래스 로딩 확인**: `new` 명령어를 만나면 해당 클래스를 가리키는 **심벌 참조**(Symbolic Reference)를 확인하고 이 클래스가 메모리(메서드 영역)에 로드되었는지 확인합니다. 로드되지 않았다면 클래스 로딩 과정을 먼저 수행합니다.
2. **메모리 할당**: 클래스 정보가 있으므로 객체에 필요한 메모리 크기가 확정됩니다. 이 크기만큼 힙 영역에서 메모리를 할당합니다. 이때 가비지 컬렉터(GC)의 압축(Compaction) 여부에 따라 할당 방식이 나뉩니다.
   - **포인터 밀치기(Bump the pointer)**: GC가 압축을 지원하여 사용중인 메모리와 여유 공간이 나뉘어 있을 때 사용됩니다. 단순히 여유 공간의 시작을 가리키는 포인터를 객체 크기만큼 이동시키는 빠른 방식입니다.
   - **여유 목록(Free list)**: 메모리가 파편화되어 있을 때 사용됩니다. JVM이 관리하는 여유 메모리 블록 리스트를 뒤져서 적절한 크기의 공간을 찾아 할당합니다.
3. **동시성 문제 해결**: 객체 생성은 매우 빈번하므로 멀티스레드 환경에서 메모리 할당 시 경합이 발생할 수 있습니다. JVM은 다음 두 가지 방식으로 이 문제를 해결합니다.
   - **CAS(Compare And Swap)**: 메모리 할당에 실패할 경우, CAS와 같은 동기화 기법을 통해 재시도하여 원자성을 보장합니다.
   - **TLAB(Thread-Local Allocation Buffer)**: (주로 사용되는 방식) 각 스레드에 힙의 Eden 영역 내에 작은 전용 버퍼를 미리 할당해 줍니다. 스레드는 이 버퍼 안에서 경합없이 자유롭게 객체를 할당하고 버퍼가 소진되면 새로운 TLAB를 동기화 과정을 거쳐 할당받습니다.
4. **메모리 0으로 초기화**: 할당된 메모리 공간을 모두 0(또는 `null`, `false`)으로 초기화합니다. 이 덕분에 개발자는 필드를 초기화하지 않아도 기본값을 갖는다고 보장받을 수 있습니다. (TLAB 사용 시에는 TLAB를 할당받을 때 이 작업이 미리 수행될 수 있습니다.)
5. **객체 헤더(Object Header) 설정**: 메모리 영역에 객체 헤더 정보를 설정합니다. 여기에는 객체가 어떤 클래스의 인스턴스인지(메타데이터 주소), 객체의 해시코드, GC 연령, 락(Lock) 상태 등의 정보가 포함됩니다.
6. 생성자 `<init>` 호출: JVM 관점에서는 5단계까지 끝나면 객체 생성이 완료됩니다. 하지만 Java 코드 관점에서는 마지막으로 객체의 생성자(`<init>` 메서드)가 호출되어야 합니다. 이 단계를 통해 개발자가 정의한 초기화 코드가 실행되고 비로소 완벽하게 사용 가능한 객체가 탄생합니다.
